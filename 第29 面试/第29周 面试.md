## 第29周 面试

### 第一节Java面试——准备

#### 第29周

```
本节课为了提高面试、笔试通过率而存在的
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221027125734225.png" alt="image-20221027125734225" style="zoom:50%;" />

#### 课程介绍

#### 自我介绍

```
自我介绍非常重要 (时长控制在两到三分钟即可)

围绕三个问题展开:
我是谁  [你好,我叫xxx,今年23岁,广东茂名人,来应聘贵公司的java软件工程师职位,2023年毕业于广州南方学院计算机科学与技术专业,从事java开发有一年时间了,对编程有一定的兴趣,擅长基于html5的互联网应用开发,擅长使用Mysql数据库,...(后面再补)]
我做过什么
我的优势在哪里
```



#### 现场面对面

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221027132810140.png" alt="image-20221027132810140" style="zoom:50%;" />

```
面试紧张该怎么做? 可以适当的降低自己的语速,当你把自己的语速降低下来,面试官也会把自己的语速降低,这样会让彼此沟通的气氛变得平和起来,能缓解紧张情绪
```



#### 面试必知必会

```html
本节帮大家梳理了一些在面试过程中经常会问到的非专业问题

<谈谈你的职业规划>  想成为管理者、想成为架构师... 但是对于这个问题来说,面试官其实他并不关心你真正五年后十年后想成为什么,而是关注你眼下到底有没有思考过这个问题。所以我们在回答这个问题的时候,要有自己的逻辑。
    
    推荐话术: 我从初中开始对软件技术就比较感兴趣,在未来的五年时间内,我希望从事于与技术相关的岗位。我给自己定了一个小目标————在五年时间内,我希望拿下系统架构师的认证,同时在分布式或者微服务的领域有自己独到的理解与建树。希望在未来的一段时间里公司可以给我提供这样成长的机会。
    
 	HR担心的是把你培养起来就跳槽走人了。
    糟糕的回答:不知道。当程序员挺好的,我就想当程序员....
    
 <与同事遇到正面冲突,你该怎么办> 面试中险恶的问题,面试官在考验你的情商。回答这个问题的主要原则是不诋毁任何人、不传递负面的情绪。面试官希望看到以大局为重的你。
     推荐话术: 我很少与别人产生正面的冲突,面对别人对我个人的指责和批评,我个人通常先会反思,我是不是真的做错了,如果是便虚心接收(尽量),尽快改正;如果是别人对我无端的诽谤,在公众场合我也会保持沉默,在私下会跟他心平气和的沟通,看看是否有什么误会。如果是在工作中,就某些问题产生了分歧,那太正常不过了,在会议室直接打开天窗说亮话,阐述自己的观点,要对事不对人,当然了话要点到即止,如果双方意见僵持不下,这可能就需要项目经理在中间作出定夺,他看待的问题可能要把我们更加的全面,也更有建设性,我的处事原则是尽量对事不对人。
     
<你生活中最重要的是什么>  对于这个问题面试官想考察你对于工作、生活、家庭是什么态度。 对于大多数的年轻人来说一定要强调以事业为重。
    推荐话术: 我一个人来到广州打拼,目前是单身,对于我现在而言事业就是我的全部,我会珍惜每一天让自己尽快的成长起来。
    
<这份工作你能预见哪些问题/困难>  典型的面试陷阱。对于这个问题,你的回答不能太过实在,如果你回答: 我的专业技能不好,我进入公司以后可能需要一段时间进行基本技能的学习....NO。
  	对于这种问题一定要学会避重就轻,找一些现实中确实已经存在的情况来进行阐述并且强调自己的一些特质,比如听话、会做、多汇报。
    推荐话术: 我对咱们公司的业务还不太了解,经验很少,进入公司以后我会听取领导的指示和要求,尽快熟悉公司的业务和技能并且制定一份近期的工作计划并报告给领导批准,最后按照计划展开工作。
    
<你希望与什么样的同事或上级共事>  险恶的陷阱问题。面试官还在考察你的情商,别太实在,面试桌上你没有选择的余地。
    推荐话术: 作为刚步入社会的新人,我应该多要求自己尽快的熟悉环境、适应环境,而不是对环境提出要求。对于我的工作,只要能发挥我的专长就可以了,如果工作中有做得不对的地方,还请领导多批评指正。
    
<你将如何开展工作>  恭喜你,当面试官问到你这个问题,说明你的面试通过几率已经很大了,因为这已经涉及到了工作的实质。在这里面试官想通过这个问题了解你的条理性和适应性。
    推荐话术: 每天会提高工作效率,完成公司交付的任务任务未完绝不下班,根据领导的指示和工作安排制定好工作计划,提前预备并按照计划完成,多请示领导,及时汇报,如果遇到不明白的地方要多向前辈们请教,抓住缝隙时间多学习多提升,尽快地提高自己的专业能力与业务水平。
    (像这样的问题其实就是一个很好的我们用来表忠心表态度的机会。因为现在你还没有进入公司,也不知道未来的领导给你安排哪些具体的工作,所以你能回答的就是体现出我们自己的工作效率以及工作的计划性)
    
    
<有想过创业吗>  恭喜你,当面试官问到你这个问题,说明你的面试通过几率已经很大了,因为这已经涉及到了工作的实质。在这里面试官想通过这个问题了解你的条理性和适应性。
    推荐话术: 我当然有想过创业,但我觉得不是现在,我计划在30岁前后选择创业,软件行业需要大量的技术积累,才能有竞争力,同时创业对我来说也需要很多的资金,我是一个刚走出校园的新人在这两方面都不成熟。所以在未来的五年十年内,我会努力的工作,在经验和资金方面做好准备,同时之所以来咱们公司,是因为咱们公司在xxx行业是一个知名企业,我想在为公司创造价值的同时也能进一步的掌握咱们行业最新的动向...
    
    
<你还应聘了哪些公司>  典型的中国式问题,其用意是想了解你是否有明确的职业目标与规划。回答这个问题千万不要说自己是海投的。因为hr给我打了电话,所以我才来公司面试。不要跨行业投简历,别人会觉得你不可信任。
    
    
<为什么你的学历是专科>  如果确实是专科还是有机会ban回一局的,因为既然你现在作为面试者已经坐在面试官的对面,就说明公司在默认情况下并不在意你的学历和院校,所以你可以利用一些话术来把劣势转为优势,同时面试官也会通过你的回答来考察你的临场反应
    推荐话术:实话实说上高中的时候,我并不是一个好学生,那个时候爱玩电脑也耽误了不少学业,但是我认为学历的高低并不一定证明能力的好坏,在我上了专科以后更加意识到因为学历比别人落后,自己就更需要努力了,后来在我亲戚的引导下,我喜欢上了编程...
    
    
<你对加班的看法>  实际上好多公司都喜欢问这个问题,但是他们并不是一定要你天天加班,而是希望通过这个问题来测试你是否愿意为公司奉献。但是如果你直接回答没问题,随时加班都可以,那这显然是一个很草率的答复,一个比较好的回答是:你要强调上班提高效率,所谓加班并不是因为我的工作效率低下而造成的。
    推荐话术:上班时间我会提高效率,做到当日事当日毕,但是如果当天的工作没有完成,我会义不容辞的加班,现在我还是单身没有家庭负担,可以全身心的投入工作。,,,...

 <你对薪资的要求(是多少)>  对薪资的回答是要十分谨慎的,要得多了可能会谈崩,要得少可能自己不满意。所以在来面试之前,你要有一个明确的主张————我自己能挣多少钱,这要参考行业的平均水平了。一般情况下HR会要求你报出具体的数字,此时可以采用下面的话术
     推荐话术:我期望的薪资是9K,每一个公司都有自己的薪资结构,咱们公司是xxx行业中有实力的企业,相当于薪资来说,我更看重技术和行业本身,如果您觉得薪资水平超出了贵公司的预期的话,这个咱们可以谈。(首先明确的阐述了自己的预期,我希望是9K,同时也表达了自己的期望[更看重企业的发展和自己的未来],所以对于薪资并不是唯一的要求。)
     
     <注意>:在谈薪资的时候不能太实在,比如心里所期望的是8k,那在报价的时候可以说8.5k或者9k,因为hr他的主要工作其中之一就是要在薪资上砍砍价,你要给下谈薪资的余地,这是其一。其二对于我们来说,千万不要说6K到8K,那这样直接暴露了你自己的底线,如果按照这种情况来报,那人家可能会更多的考虑给你6k而不是8k,这里是要注意的。
         
         
         
 <谈谈你对跳槽的看法>  陷阱问题,一定要谨慎。千万不要流露出任何负面信息,这个问题说得越少越好
     推荐话术:我这个人稳定性很好,本身反对频繁跳槽,但是有一种情况我会选择跳槽,就是公司的发展和我的事业规划不符,我之前在进入xxx公司的时候,公司主要从事金融行业的项目开发,后来该行业经营不理想,改做电信行业了,但我的长期规划是想成为金融软件行业的资深的软件工程师与架构师,如果遇到这种情况我会毫不犹豫的选择离开。(强调了外在的因素)
    
```



#### 给职场新人的建议

```java
1.不要有为老板工作的心态
2.永远不要敷衍工作
3.事情做完马上汇报
4.管理好自己的情绪,做一个可爱的人
5.接受任务有确认机制
6.注意工作汇报方式
7.注重细节
8.提建议要有数据支撑
9.要提升自己的价值
10.认真对待工作汇报
```



```
要给老板选择题而不是判断题或者问问题
```



### 第二节Java面试——Java基础面试技巧

#### JDK、JER、JVM有什么区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101152445602.png" alt="image-20221101152445602" style="zoom:40%;" />



#### 常用数学类型的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101152937955.png" alt="image-20221101152937955" style="zoom:40%;" />



#### Float在JVM中的表达方式及使用陷阱

```
float类型在内存中的存储形式为科学计数法,表达为:4.2343242E7。小数点后最多保存七位

```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101153758704.png" alt="image-20221101153758704" style="zoom:33%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101153648796.png" alt="image-20221101153648796" style="zoom:40%;" />



#### 随机数的使用

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101190334361.png" alt="image-20221101190334361" style="zoom:40%;" />

```java
package com.wei.interview;
import java.util.Random;

public class RandomSample {
    public Integer randomInt1() {
        int min = 30;
        int max = 100;

        // nextInt(70)方法 含义是 生成随机数的范围是 0~70
        int result = new Random().nextInt(max - min) + min;
        return result;
    }

    public Integer randomInt2() {
        int min = 30;
        int max = 100;

        // Math.random()用于生成从0~1的随机小数
        int result = (int) (Math.random() * (max - min));
        //int result = (int) (Math.random() * (max - min))+min; 讲课视频的写法
        return result;
    }

    public static void main(String[] args) {
        System.out.println("randomInt1 :" + new RandomSample().randomInt1());
        System.out.println("randomInt2 :" + new RandomSample().randomInt2());
    }}
```



#### 找出1-1000内的质数

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101213704409.png" alt="image-20221101213704409" style="zoom:50%;" />

```java
package com.wei.interview;

public class PrimeNumber {
    public void isPrimeNumber() {
        int max = 100;
        int count = 0;
        for (int i = 2; i < max; i++) {
            boolean flag = true;
            for (int j = 2; j < i; j++) {
                if (i % j == 0) {
                    flag = false;
                    break;
                }}
            if (flag) {
                System.out.println(i);
                count++;
            }}
        System.out.println("总数是 "+count);
    }

    public static void main(String[] args) {
        new PrimeNumber().isPrimeNumber();}}
```



#### 面向对象三大特性是什么

```
封装、继承、多态

封装:我想让你看到的,你能看到;不想让你看到的,就见不到。 对于封装,我们也称为信息的隐藏
继承:
多态:
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221108234402820.png" alt="image-20221108234402820" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221108234442077.png" alt="image-20221108234442077" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221108234520442.png" alt="image-20221108234520442" style="zoom:40%;" />

#### 静态与实例变量的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221108234622734.png" alt="image-20221108234622734" style="zoom:40%;" />

```
静态变量和实例变量存储的地方也是不同的:静态变量存储在我们的JVM的方法区中，而实例变量则存在于对象堆的内存中。
作为实际开发的时候,静态变量它的存储空间是相对比较小的,而实例变量存储的空间比较多,在我们java面向对象编程中,我们在绝大多数场景下推荐优先使用实例变量
```

#### 类的执行顺序

```java
请写出程序输出结果
1.静态优先
2.父类优先
3.非静态块优先于构造函数
```

#### java的异常体系

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221108235819009.png" alt="image-20221108235819009" style="zoom:40%;" />

#### String与字符串常量池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221116183939305.png" alt="image-20221116183939305" style="zoom:40%;" />

```
考察的是我们对于字符串底层存储的了解,我们都知道对于字符串它一旦创建以后就是final修饰的,也就是不可变。同时字符串默认会保存在我们方法区中特定开辟的区域叫做常量池。那么当字符串创建好了以后,常量池就会出现这个字符串的常量,不同的String对象引用相同的字符串的时候,其实就是指向同一个我们字符串的内存地址,
```

```java
package com.wei.interview;

/**
 * String与字符串常量池
 *
 * 考察的是我们对于字符串底层存储的了解,我们都知道对于字符串它一旦创建以后就是final修饰的,也就是不可变。
 * 同时字符串默认会保存在我们方法区中特定开辟的区域叫做常量池。
 * 那么当字符串创建好了以后,常量池就会出现这个字符串的常量,不同的String对象引用相同的字符串的时候,其实就是指向同一个我们字符串的内存地址
 */

public class StringAndStringConstantPool {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        String s3 = "abc"+"def";
        String s4 = "abcdef";
        //s2算是一个引用类型,对于引用类型,java、编译器在编译期间是无法确定它的数值的,
        // 也就意味着我们无法使用编译器对它进行优化,只有在运行时这个s2才能确定具体的值,因此即使是s2=abc它加上def之后,
        // 它会产生一个新的内存地址同时分配给s5,因为s4、s5它们的内存地址是不同的,所以返回是false,
        String s5 = s2+"def";
        //s1是存放在常量池中的常量,而s6 new String("abc")它创建的字符串对象是不会在常量池中的保存的,存储的地址不同,
        String s6 = new String("abc");

        //s1 == s2 就是在比较内存地址。
        // 那equals()方法比较的是字符串的内容是否相同
        //s1和s2都指向"abc" 这个地址
        System.out.println(s1 ==s2); //true
        System.out.println(s3 ==s4); //true
        System.out.println(s4 ==s5); //false
        System.out.println(s4.equals(s5)); //true？
        System.out.println(s2==s6); //false
        System.out.println(s2.equals(s6)); //true
}}
```



#### String、StringBuilder、StringBuffer的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221116194120118.png" alt="image-20221116194120118" style="zoom:40%;" />



#### List与Set的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221121234904076.png" alt="image-20221121234904076" style="zoom:40%;" />



##### ArrayList与LinkedList的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221121235028288.png" alt="image-20221121235028288" style="zoom:40%;" />

##### HashSet和TreeSet的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221121235333509.png" alt="image-20221121235333509" style="zoom:40%;" />

```
哈希值生成具有不确定性
```

#### List排序的编码实现

##### 编程题: List排序

```java
package com.wei.interview.sorter;
public class Employee {
    private String name;
    private Integer age;
    private Float salary;
    public Employee() {

    }

    //带三个参数的构造方法,能快速创建employee对象
    public Employee(String name, Integer age, Float salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }

    public Float getSalary() {return salary;}
    public void setSalary(Float salary) {this.salary = salary;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name; }
    public Integer getAge() {return age;}
    public void setAge(Integer age) {this.age = age;}

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", salary=" + salary +
                '}'; }}
```

```java
//主要是Comparator接口能实现。 List和Set都能用
package com.wei.interview.sorter;
import java.util.*;

public class ListSorter {
    public static void main(String[] args) {
        //如何按工资升序进行排列
        List<Employee> employees = new ArrayList<Employee>();
        employees.add(new Employee("xiao m", 24, 3900f));
        employees.add(new Employee("yang", 25, 3800f));
        employees.add(new Employee("wei", 24, 5900f));

        Collections.sort(employees, new Comparator<Employee>() {
            @Override  //compare返回是一个正数的话,代表 o1大于o2
            public int compare(Employee o1, Employee o2) {
                return (int) (o2.getSalary() - o1.getSalary());
            }});
        //对已有的employees了一个调整,直接输出即可
        System.out.println(employees);}}
```



#### TreeSet排序的编码实现

```java
package com.wei.interview.sorter;

//要实现自然排序就需要在employee中实现一个Comparable接口
public class Employee implements Comparable<Employee> {
    private String name;
    private Integer age;
    private Float salary;
    public Employee() {

    }

    //带三个参数的构造方法,能快速创建employee对象
    public Employee(String name, Integer age, Float salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;}

    public Float getSalary() { return salary;}
	.....

    @Override
    public int compareTo(Employee o) {
        //如果前面比后面大则返回1。 如果前面比后面小则返回负一。 两者相等则返回零,代表取前面的元素
        return o.getAge().compareTo(this.getAge());  //这样是降序。要用相同的属性进行比较
//        return this.getAge().compareTo(o.getAge());
    }}
```

```java
//TreeSet的两种排序方式。原理是红黑树? 比较返回的是-1则放在红黑树的左边,即降序排列。反之放在右边,升序

package com.wei.interview.sorter;
import java.util.Comparator;
import java.util.TreeSet;

public class SetSorter {
    public static void main(String[] args) {
        TreeSet<Employee> employees = new TreeSet<Employee>();
//        TreeSet<Employee> employees = new TreeSet<Employee>(new Comparator<Employee>() {
//            @Override
//            public int compare(Employee o1, Employee o2) {
//                return (int) (o2.getSalary() - o1.getSalary());
//            }
//        });
        employees.add(new Employee("xiao m", 24, 3900f));
        employees.add(new Employee("yang", 25, 3800f));
        employees.add(new Employee("wei", 22, 5900f));
        System.out.println(employees);}}
```



#### Object类hashCode() 和equals()的区别

```
equals考量的比较多,运行速度慢,更可靠。(考虑各种因素)

hashCode() 不太可靠   (有可能不同的对象产生相同的hashCode)
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221124234944216.png" alt="image-20221124234944216" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221124234907024.png" alt="image-20221124234907024" style="zoom:40%;" />



#### Java IO中有几种类型的流

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221201165158365.png" alt="image-20221201165158365" style="zoom:50%;" />

```
字节就是二进制文件
字符是可读的字符

对于字节输入流顶层的抽象类是 InputStream, FileInput是具体实现类。
```



#### 利用IO实现文件复制

##### 编程题:复制文件到指定文件夹





#### JVM的内存组成

##### 提问:JVM的组成/构成

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221206234843890.png" alt="image-20221206234843890" style="zoom:40%;" />

```
方法区(Method Area)、
堆(Heap)、
程序计数器PC、
虚拟机栈(VM Stack)、
本地方法栈(Native Method Stack)


最重要的堆:堆是java虚拟机所管理的内存中最大的一块,它唯一的目的是存放在程序运行时所创建的对象实例,堆是垃圾回收的主要区域,对于垃圾回收来说主要是在堆中进行处理。对于那些不再被使用————也就是没有持有引用的对象,那么java的垃圾回收器在堆中对其进行回收及销毁。堆是java中管理的最大的一块内存区域,也是最主要的内存区域。


方法区主要用于存储虚拟机加载的类的信息,常量、静态变量等数据。 静态变量所有的内容都存储在方法区中。
对于方法区和堆一样是被所有线程共享的,可以开放、直接访问的。
对于存放在方法区中的数据,java的垃圾回收器是很少对其进行垃圾回收的,但它也不是不回收,主要回收的是常量以及内存卸载的信息,对于我们常见的静态变量是不进行回收的 (如果是静态常量是引用类型是有可能被回收的)

程序计数器:在程序涉及到分支、跳转的时候它用计数器来记录行号。这是最典型的应用

虚拟机栈:栈和堆与不同,是线程私有的。在栈中主要是为Java的方法服务,当线程创建的时候,虚拟机栈会为线程分配一块内存区域,在线程执行过程中调用的每个方法都会创建一个栈针(栈针可以看做是对当前方法的引用)。

本地方法栈:与虚拟机栈非常相似,他们的用途有区别。主要区别在于:虚拟机栈是为执行java方法时所提供的。 而本地方法栈则是为执行本地方法时所服务的。
```



#### GC垃圾回收及算法介绍

##### 请简述Java的垃圾回收机制(GC)

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221219204346575.png" alt="image-20221219204346575" style="zoom:50%;" />

```
垃圾回收器来说,它是一把双刃剑,一方面对于程序开发它提供了便捷,另外一方面正是因为垃圾回收要不断的对我们内存进行监听,所以执行效率相当于C或C++语言来说要低一些,但是随着技术发展以及软硬件的规格在不断提高,这两者的差距在不断的缩小,

对于垃圾回收器来说,它使用的是有向图的方式来记录和管理堆内存中的所有对象。通过有向图可以识别哪些对象是可达的,哪些对象是不可达的。对于可达对象与予保留,对于不可达的对象视为垃圾将会被垃圾回收器处理掉,,


```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221219203455361.png" alt="image-20221219203455361" style="zoom:50%;" />

##### 垃圾回收(GC)算法

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221219204314962.png" alt="image-20221219204314962" style="zoom: 50%;" />

#### java的内存泄露场景

##### 请举例Java中内存泄露的场景

```
内存泄露是指一个不再需要被使用的对象或者变量还在内存中占有着它的空间。在C或者C++语言中内存的分配和释放是由开发人员手动操作的。如果程序员忘记了释放那么就会造成内存泄露。但是java在引入了垃圾回收机制的时候,由垃圾回收器自动的回收,那么可以极大程度上降低程序员这方面的工作,但是不意味着java不会出现内存泄露的场景, (java垃圾回收的基准是 这个对象是否可达。)

人为失误造成的内存泄露场景:
1.静态集合类
(静态对象存储在方法区中,作为垃圾回收器几乎不会对方法区(方法区比较小)里的东西进行高频的回收。比如静态集合类量大的话,久而久之可能会发生了内存泄露)
2.各种连接  (比如打开文件忘记了close)
3.监听器	(监听网络端口)
4.不合理的作用域 (编程好习惯之一:作用域最小化)
,,,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221219215501026.png" alt="image-20221219215501026" style="zoom:50%;" />

#### 请实现对象的浅复制和深复制



### 第三节Java面试——Web基础与数据处理

#### 请说明Servlet执行流程

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221223232550233.png" alt="image-20221223232550233" style="zoom:60%;" />

```
Servlet是什么时候被实例化的? (面试陷阱)
对于我们来说,Servlet并不是在Tomcat Web应用程序启动的时候进行实例化的,而是在第一次访问Servlet的时候来进行的。同时对于Servlet来说,它是全局在Tomcat中有且只有唯一的一个对象,Tomcat并不会创建Servlet的多个实例。那么衍生出来一个新的问题,对于Servlet来说,如果在并发环境下,它是怎么处理的?  答:Servlet的处理是基于单例多线程,利用多线程技术来提供Web服务。说到多线程就不得不说到线程安全的问题,因为所有的线程都共享了一个Servlet的实例,所以我们在使用Servlet的时候,不允许在Servlet内创建存在状态的变量或者是对象,这样会在并发访问时产生无法预期的结果,
```



#### Servlet生命周期

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230119230436557.png" alt="image-20230119230436557" style="zoom:50%;" />



#### 请求和响应的结构

##### 请阐述HTTP请求的结构

```
请求: 是指从浏览器向服务器发送的数据包

响应: 是指服务器返回给浏览器的结果,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230120172336807.png" alt="image-20230120172336807" style="zoom: 50%;" />

```
get 请求没有请求体,get请求是直接把信息放在url中的。 post请求有。
```





#### 请求转发与响应重定向的区别

##### 请求转发

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230121015356506.png" alt="image-20230121015356506" style="zoom: 50%;" />

##### 响应从定向

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230121022402574.png" alt="image-20230121022402574" style="zoom:50%;" />



#### 请阐述Session的原理

```
Session是指与 客户端浏览器窗口绑定的且存储在服务器内部的用户数据就称之为 Session。

```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230123140130498.png" alt="image-20230123140130498" style="zoom:40%;" />

```
从表现形式上来说,能感觉到它们执行了相似的操作但是因为tomcat底层使用了独立的区域对这些数据进行保存,所以他们展现的结果是完全不同的,
```



#### JSP九大内置对象

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230123140713083.png" alt="image-20230123140713083" style="zoom:40%;" />

#### Statement和PreparedStatement的区别

```
PreparedStatement支持参数化操作

优先使用 PreparedStatement
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230124234020231.png" alt="image-20230124234020231" style="zoom:40%;" />

#### 请说明JDBC使用步骤

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20230127224307291.png" alt="image-20230127224307291" style="zoom:40%;" />

```java
package com.wei.interview.jdbc;
import java.sql.*;
public class MysqlJDBC {
    public static void main(String[] args) {
        String driverName = "com.mysql.cj.jdbc.Driver";
        String URL = "jdbc:mysql://127.0.0.1:3306/scott";
        String sql = "SELECT  * from user";
        String username = "root";
        String password = "1234";
        Connection connection = null;
        try {
            //1.加载JDBC驱动           
            Class.forName(driverName);
            //2.建立连接
            connection = DriverManager.getConnection(URL, username, password);
            //3.创建命令(Statement)
            Statement statement = connection.createStatement();
            //4.处理结果 (结果集对象)
            ResultSet resultSet = statement.executeQuery(sql);
            //遍历结果集
            while (resultSet.next()) {
                System.out.println(resultSet.getString("name")
                        + resultSet.getString("age"));
            }
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        } finally {
            if (connection != null) {
                try {
                    //5.关闭当前连接
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace(); }}}}}
```

#### SQL编程题目-1

