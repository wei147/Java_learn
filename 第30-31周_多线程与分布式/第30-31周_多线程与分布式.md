

## 第30-31周_多线程与分布式

#### 多线程与分布式 周介绍

```
第五阶段主要包括 分布式与微服务相关的内容。

个人感受:感觉挺多新奇的、没有了解过的知识点,冲
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012237328.png" alt="image-20221028012237328" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012450782.png" alt="image-20221028012450782" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012618434.png" alt="image-20221028012618434" style="zoom:50%;" />



### 第一节 线程池

#### 初识线程池

##### 初识线程池——治理线程的最大法宝

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028105746921.png" alt="image-20221028105746921" style="zoom:50%;" />

##### 线程池的自我介绍

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028110913536.png" alt="image-20221028110913536" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028112331999.png" alt="image-20221028112331999" style="zoom:50%;" />

```java
线程池为什么这么重要? 实际上如果我们想成为一个好的java工程师的话,还是需要非常好的掌握线程池这个知识的,其实很多问题都是因为我们没有用好线程池,所导致的...

线程池总体来讲有两个好处:第一个是可以复用我们的每一个线程;第二个就是可以控制我们资源的总量。

如果不用线程池会怎么样? 如果不使用线程池,每来一个任务就新开一个线程,

package threadpool;
/**
 * 每一个任务创建一个线程
 */
public class ForLoop {
    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            Thread thread = new Thread(new Task());
            //启动线程
            thread.start();}}

    static class Task implements Runnable {
        @Override
        public void run() {
            System.out.println("执行了方法");}}}

为什么说这是一种笨拙的方法?  因为我们对于java语言而言,每一个java中的线程会直接对应到操作系统中的线程,这样一来相当是在操作系统中创建了1000个线程,这个会带来很大的开销,线程的生命周期的开销是非常高的,线程的创建和销毁不是没有代价的,它希望我们jvm和操作系统提供一些辅助操作,在这种大量线程创建的时候,会消耗很多的资源,尤其是内存,而且这些线程创建之后还需要被回收,又会给垃圾回收器带来压力,并且我们系统、包括程序所创建线程是有上限的,从1000变到20万该怎么办,任务数量是不受我们控制的,但是线程数量是有上限的。所以我们就知道了有任务过来,不是每一个任务都需要或者有必要去新建一个线程来执行的。  这就是我们为要使用线程池的原因
    
实际tomcat等服务器也是用线程池来实现的
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028113655278.png" alt="image-20221028113655278" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114027647.png" alt="image-20221028114027647" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114214587.png" alt="image-20221028114214587" style="zoom:50%;" />



#### 线程增减的时机

##### 创建和停止线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028164825816.png" alt="image-20221028164825816" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165009181.png" alt="image-20221028165009181" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165359766.png" alt="image-20221028165359766" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028171041448.png" alt="image-20221028171041448" style="zoom:50%;" />

```
Current size最大能扩展到Max pool size
```

#### 添加线程规则

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172347027.png" alt="image-20221028172347027" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172648806.png" alt="image-20221028172648806" style="zoom:50%;" />

```
烧烤店里边有五张桌(5个核心线程),客人来了里边人没满就会往里边坐。当客人来了,里边满人了就会拓展店外边————外边新增5张桌子(最大线程数是5+5=10)。当收摊的时候,外边五张桌子会被收回来,而原本在里边的桌子始终存在。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028173448882.png" alt="image-20221028173448882" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174924714.png" alt="image-20221028174924714" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174946961.png" alt="image-20221028174946961" style="zoom:50%;" />



#### 线程存活时间和工作队列

##### keppAliveTime

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175400995.png" alt="image-20221028175400995" style="zoom:50%;" />

##### ThreadFactory 用来创建线程的

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175535761.png" alt="image-20221028175535761" style="zoom:50%;" />



##### 工作队列

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028223857757.png" alt="image-20221028223857757" style="zoom:50%;" />

```
直接交换:存不下任务的,注意 maxSize可能要设置大一些,
无界队列:不会被塞满。可以防止流量突增,但是有风险处理速度跟不上任务提交的速度,越积越多可能会造成内存浪费或者oom异常
有界队列:可以设置队列大小,,
```



#### 自动创建线程池的风险

##### 线程池应该手动创建还是自动创建?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028222308192.png" alt="image-20221028222308192" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028225136828.png" alt="image-20221028225136828" style="zoom:50%;" />

```java
//演示了这种newFixedThreadPool带来的一种可能出错的情况,这就意味着我们用这种固定的数量的线程池还是要额外注意的,,
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示newFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM {
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executorService.execute(new SubThread());
        }}}

class SubThread implements Runnable{
    @Override
    public void run() {
        try {
            //这个任务的特点就是一直在睡觉。因为不想这个任务被执行完毕,因为被执行完毕之后,这个任务就结束了进入下一个任务,
            // 我们的目标是把这个队列塞满,随着时间增加,队列里的任务越来越多才可能触发OOM错误
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();}}}
```



#### 常用线程池的用法表示

##### newSingleThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230213227.png" alt="image-20221028230213227" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 简单的线程池,这个线程池里只有一个固定的线程,
 */
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());
        }}}
```



##### CacheThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230413476.png" alt="image-20221028230413476" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CacheThreadPool {
    public static void main(String[] args) {
        //线程几乎是可以无限创建的,如果线程数量特别多任务数量特别多,也有可能会导致oom,
        ExecutorService executorService = Executors.newCachedThreadPool();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());}}}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028231651595.png" alt="image-20221028231651595" style="zoom:50%;" />



##### ScheduledThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduleThreadPoolTest {
    public static void main(String[] args) {
        //
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        //这里的放任务和刚才的不太一样
        threadPool.schedule(new FixedThreadPoolTest.Task(), 3, TimeUnit.SECONDS); //延迟3秒才执行 TimeUnit.SECONDS是指定单位为秒

        //以一定频率重复运行,(开始时间是1秒后,然后是隔3秒运行一次,)
        threadPool.scheduleAtFixedRate(new FixedThreadPoolTest.Task(), 1, 3, TimeUnit.SECONDS);
    }}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221029004544354.png" alt="image-20221029004544354" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221029011647545.png" alt="image-20221029011647545" style="zoom:50%;" />



#### 对比各种线程池的特点

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030233634878.png" alt="image-20221030233634878" style="zoom: 50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030234236113.png" alt="image-20221030234236113" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030234614951.png" alt="image-20221030234614951" style="zoom:50%;" />

```
1.因为FixedThreadPool和SingleThreadExecutor核心线程数和最大线程数都是被确定的,就需要这个无限队列来容纳任务数,
2.CachedThreadPool是来一个任务就创建一个线程
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031001148928.png" alt="image-20221031001148928" style="zoom:50%;" />

```
workStealingPool不保证执行顺序.不是那么常用
```



#### 如何正确关闭线程池

##### 停止线程池的正确方法

```
shutdown(); 方法并不是一上来就把所有线程任务就停止了,而是会拒绝后续提交的错误并抛出异常,并没有完全停止,

isTerminated(); 里面的线程包括正在执行的任务、包括队列里的任务都清空了才会返回true
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031130335366.png" alt="image-20221031130335366" style="zoom: 33%;" />

```java
package threadpool;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class ShuntDown {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ShuntDownTask());}

        Thread.sleep(1500);
        //shutdownNow() 的威力是比较大的,列队内的还没来得及执行的任务则会被返回(runnableList)[一般会做进一步的处理,比如记录或者是重新执行]
        List<Runnable> runnableList = executorService.shutdownNow();
        System.out.println(runnableList.toString());
//        executorService.shutdown();
//        //这3秒钟会阻塞并返回一个布尔值。(三秒钟之内没有没有完全停止,还没有停止就打印false)
//        boolean b = executorService.awaitTermination(7, TimeUnit.SECONDS);
//        System.out.println(b);
//        System.out.println((executorService.isShutdown()));
//        executorService.shutdown(); //这里用了 shutdown,后面再加入任务就会报错 RejectedExecutionException
//        executorService.execute(new ShuntDownTask());
//        System.out.println((executorService.isShutdown()));
//        System.out.println("isTerminated: "+executorService.isTerminated());
//        Thread.sleep(9000);
//        System.out.println("isTerminated: "+executorService.isTerminated());
    }

    static class ShuntDownTask implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(500);
                System.out.println(Thread.currentThread().getName());
            } catch (InterruptedException e) {
                //在睡眠期间假设有中断信号过来,会抛出这个异常
//                e.printStackTrace();
                System.out.println(Thread.currentThread().getName()+"被中断了");}}}}
```



#### 暂停和恢复线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031130846522.png" alt="image-20221031130846522" style="zoom: 50%;" />

```java
拒绝时机1:
executorService.shutdown(); //这里用了 shutdown,后面再加入任务就会报错 RejectedExecutionException
executorService.execute(new ShuntDownTask());
```

##### 4钟拒绝策略

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031132654562.png" alt="image-20221031132654562" style="zoom:33%;" />

```
四种拒绝策略:
AbortPolicy  (直接抛出一个异常,说明没有提交成功)
DiscardPolicy  (默默地把任务丢弃,不会得到通知,所以你也不知道这个任务不会得到处理)
DiscareOldestPolicy  (最老的、存在时间最久的任务丢弃掉)
CallerRunsPolicy  (谁提交的这个任务,谁就帮我去跑。比如主线程给线程池提交任务,线程池真的没有办法容纳了,它已经饱和了,那么这个时候就会让这个主线程————也就是提交任务的这个线程去执行,比较聪明的策略)

评价:第四种是无损的会让呼叫者线程去执行,1.避免避免了业务损失  2.可以让我们提交的速度降低下来,这是一种负反馈:比如主线程一直提交任务,但采用这种拒绝策略会让主线程自己去执行该任务(线程池已满返回给主线程执行),当主线程执行这些任务的时候也给了线程池的缓冲时间,

```

##### 钩子方法,给线程加点料

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031132929249.png" alt="image-20221031132929249" style="zoom:33%;" />

```
可以在每个任务执行之前和之后做一些事情,比如说日志或者说统计都可以
```

```
线程池利用了钩子函数拥有了暂停和恢复的能力
```

```java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 可暂停的线程池。演示每个任务执行前后放钩子函数  (钩子函数在设计模式中也是经常会被用到的)
 */

//继承于普通的线程池
public class PausableThreadPool extends ThreadPoolExecutor {

    //标记位。就是用来标记该线程是不是现在处于暂停状态的,,,,
    private boolean isPaused;
    //为了让这个布尔值的并发修改是安全的,我们给它上一把锁
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unPaused = lock.newCondition();


    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    //钩子函数登场,实际上是一个重写的方法。
    // 在每一次执行这个任务之前都会调用这个函数并且在这个函数中它会去检查 isPaused是不是想暂停了,如果是会让当前这个线程暂停,而不再继续执行 unPaused.await();
    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try {
            //在方法内部做一个检测:如果确实是true,说明我们确实想让它暂停
            while (isPaused) {
                unPaused.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            //解锁
            lock.unlock();
        }
    }

    //暂停方法
    private void pause() {
        //在这里锁住之后,我们运用这样的锁锁住之后,一定要记得这样的锁一定要用try catch finally,否则可能会出现这个锁永远不释放的情况,
        lock.lock();
        try {
            isPaused = true;
        } finally {
            lock.unlock();
        }
    }

    //恢复函数
    public void resume() {
        lock.lock();
        //把之前暂停的去唤醒
        try {
            isPaused = false;
            unPaused.signalAll(); //唤醒全部的方法
        } finally {
            lock.unlock();
        }
    }


    public static void main(String[] args) {
        PausableThreadPool pausableThreadPool = new PausableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>());
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("被执行了");
                try{
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        for (int i = 0; i < 1000; i++) {
            pausableThreadPool.execute(runnable);
        }
        try {
            Thread.sleep(1500);
            pausableThreadPool.pause();
            System.out.println("线程池被暂停了");
            Thread.sleep(1500);
            pausableThreadPool.resume();
            System.out.println("线程池被恢复了");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } }}
```



#### 线程池实现复用的原因

##### 实现原理、源码分析

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223535412.png" alt="image-20221031223535412" style="zoom: 33%;" />

```
idea Structure模块,感觉太实用了,可以看到该接口下的所有方法,并且提供了点击定位和看到返回值
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031222032761.png" alt="image-20221031222032761" style="zoom:50%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223622662.png" alt="image-20221031223622662" style="zoom:33%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223650002.png" alt="image-20221031223650002" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223725951.png" alt="image-20221031223725951" style="zoom:50%;" />



#### 线程池状态和使用注意点

##### 线程池状态

```
线程有状态,线程池也有状态
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223845121.png" alt="image-20221031223845121" style="zoom: 40%;" />

```
接着就是讲解源码的阶段 ....

使用线程池的注意点  第三点是线程始终结束不了会产生严重后果
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031230350793.png" alt="image-20221031230350793" style="zoom:50%;" />



#### 课程总结





### 第2节 ThreadLocal

#### ThreadLocal章节介绍

##### ThreadLocal 详解——这一次彻底掌握

```
非常重要的工具类 ThreadLocal
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031231306337.png" alt="image-20221031231306337" style="zoom:40%;" />

#### ThreadLocal的两种典型应用场景

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101214841152.png" alt="image-20221101214841152" style="zoom:40%;" />

#### 第一种典型场景

```
强调的是 每个Thread内有自己的实例副本,不共享
例子:如果班上30个同学只有一本教材,大家又想使用这本教材的话,那么很有可能就是说会抢着看的同时会可能抢着做笔记,那么自然就会发生线程安全的问题,就是并发的读写会带来数据不一致。而用来TreadLocal,旧等于是把这本教材去复印了30份,这样每个人都使用自己的书这样就不会出问题了。而这里的每一本书,每一个实例都只能用当前那个Thread当前的那个线程访问到,并且使用,其他线程是访问不到的,这也是ThreadLocal名字的由来,TreadLocal 线程本地,想表达的内容是这个副本只能被我这个线程本人本地所使用,其他线程是没有办法访问的,不是共用的,这样也不存在多线程的共享问题,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101221654828.png" alt="image-20221101221654828" style="zoom:40%;" />

