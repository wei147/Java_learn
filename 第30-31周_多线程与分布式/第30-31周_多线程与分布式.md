## 第30-31周_多线程与分布式

#### 多线程与分布式 周介绍

```
第五阶段主要包括 分布式与微服务相关的内容。

个人感受:感觉挺多新奇的、没有了解过的知识点,冲
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012237328.png" alt="image-20221028012237328" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012450782.png" alt="image-20221028012450782" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012618434.png" alt="image-20221028012618434" style="zoom:50%;" />



### 第一节 线程池

#### 初识线程池

##### 初识线程池——治理线程的最大法宝

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028105746921.png" alt="image-20221028105746921" style="zoom:50%;" />

##### 线程池的自我介绍

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028110913536.png" alt="image-20221028110913536" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028112331999.png" alt="image-20221028112331999" style="zoom:50%;" />

```java
线程池为什么这么重要? 实际上如果我们想成为一个好的java工程师的话,还是需要非常好的掌握线程池这个知识的,其实很多问题都是因为我们没有用好线程池,所导致的...

线程池总体来讲有两个好处:第一个是可以复用我们的每一个线程;第二个就是可以控制我们资源的总量。

如果不用线程池会怎么样? 如果不使用线程池,每来一个任务就新开一个线程,

package threadpool;
/**
 * 每一个任务创建一个线程
 */
public class ForLoop {
    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            Thread thread = new Thread(new Task());
            //启动线程
            thread.start();}}

    static class Task implements Runnable {
        @Override
        public void run() {
            System.out.println("执行了方法");}}}

为什么说这是一种笨拙的方法?  因为我们对于java语言而言,每一个java中的线程会直接对应到操作系统中的线程,这样一来相当是在操作系统中创建了1000个线程,这个会带来很大的开销,线程的生命周期的开销是非常高的,线程的创建和销毁不是没有代价的,它希望我们jvm和操作系统提供一些辅助操作,在这种大量线程创建的时候,会消耗很多的资源,尤其是内存,而且这些线程创建之后还需要被回收,又会给垃圾回收器带来压力,并且我们系统、包括程序所创建线程是有上限的,从1000变到20万该怎么办,任务数量是不受我们控制的,但是线程数量是有上限的。所以我们就知道了有任务过来,不是每一个任务都需要或者有必要去新建一个线程来执行的。  这就是我们为要使用线程池的原因
    
实际tomcat等服务器也是用线程池来实现的
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028113655278.png" alt="image-20221028113655278" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114027647.png" alt="image-20221028114027647" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114214587.png" alt="image-20221028114214587" style="zoom:50%;" />



#### 线程增减的时机

##### 创建和停止线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028164825816.png" alt="image-20221028164825816" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165009181.png" alt="image-20221028165009181" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165359766.png" alt="image-20221028165359766" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028171041448.png" alt="image-20221028171041448" style="zoom:50%;" />

```
Current size最大能扩展到Max pool size
```

#### 添加线程规则

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172347027.png" alt="image-20221028172347027" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172648806.png" alt="image-20221028172648806" style="zoom:50%;" />![image-20221028173448882](C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028173448882.png)

```
烧烤店里边有五张桌(5个核心线程),客人来了里边人没满就会往里边坐。当客人来了,里边满人了就会拓展店外边————外边新增5张桌子(最大线程数是5+5=10)。当收摊的时候,外边五张桌子会被收回来,而原本在里边的桌子始终存在。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028173448882.png" alt="image-20221028173448882" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174924714.png" alt="image-20221028174924714" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174946961.png" alt="image-20221028174946961" style="zoom:50%;" />



#### 线程存活时间和工作队列

##### keppAliveTime

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175400995.png" alt="image-20221028175400995" style="zoom:50%;" />

##### ThreadFactory 用来创建线程的

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175535761.png" alt="image-20221028175535761" style="zoom:50%;" />



##### 工作队列

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028223857757.png" alt="image-20221028223857757" style="zoom:50%;" />

```
直接交换:存不下任务的,注意 maxSize可能要设置大一些,
无界队列:不会被塞满。可以防止流量突增,但是有风险处理速度跟不上任务提交的速度,越积越多可能会造成内存浪费或者oom异常
有界队列:可以设置队列大小,,
```



#### 自动创建线程池的风险

##### 线程池应该手动创建还是自动创建?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028222308192.png" alt="image-20221028222308192" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028225136828.png" alt="image-20221028225136828" style="zoom:50%;" />

```java
//演示了这种newFixedThreadPool带来的一种可能出错的情况,这就意味着我们用这种固定的数量的线程池还是要额外注意的,,
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示newFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM {
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executorService.execute(new SubThread());
        }}}

class SubThread implements Runnable{
    @Override
    public void run() {
        try {
            //这个任务的特点就是一直在睡觉。因为不想这个任务被执行完毕,因为被执行完毕之后,这个任务就结束了进入下一个任务,
            // 我们的目标是把这个队列塞满,随着时间增加,队列里的任务越来越多才可能触发OOM错误
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();}}}
```



#### 常用线程池的用法表示

##### newSingleThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230213227.png" alt="image-20221028230213227" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 简单的线程池,这个线程池里只有一个固定的线程,
 */
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());
        }}}
```



##### CacheThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230413476.png" alt="image-20221028230413476" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CacheThreadPool {
    public static void main(String[] args) {
        //线程几乎是可以无限创建的,如果线程数量特别多任务数量特别多,也有可能会导致oom,
        ExecutorService executorService = Executors.newCachedThreadPool();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());}}}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028231651595.png" alt="image-20221028231651595" style="zoom:50%;" />



##### ScheduledThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduleThreadPoolTest {
    public static void main(String[] args) {
        //
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        //这里的放任务和刚才的不太一样
        threadPool.schedule(new FixedThreadPoolTest.Task(), 3, TimeUnit.SECONDS); //延迟3秒才执行 TimeUnit.SECONDS是指定单位为秒

        //以一定频率重复运行,(开始时间是1秒后,然后是隔3秒运行一次,)
        threadPool.scheduleAtFixedRate(new FixedThreadPoolTest.Task(), 1, 3, TimeUnit.SECONDS);
    }}
```