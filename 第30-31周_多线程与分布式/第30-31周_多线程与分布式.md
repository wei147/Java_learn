## 第30-31周_多线程与分布式

#### 多线程与分布式 周介绍

```
第五阶段主要包括 分布式与微服务相关的内容。

个人感受:感觉挺多新奇的、没有了解过的知识点,冲
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012237328.png" alt="image-20221028012237328" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012450782.png" alt="image-20221028012450782" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012618434.png" alt="image-20221028012618434" style="zoom:50%;" />



### 第一节 线程池

#### 初识线程池

##### 初识线程池——治理线程的最大法宝

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028105746921.png" alt="image-20221028105746921" style="zoom:50%;" />

##### 线程池的自我介绍

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028110913536.png" alt="image-20221028110913536" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028112331999.png" alt="image-20221028112331999" style="zoom:50%;" />

```java
线程池为什么这么重要? 实际上如果我们想成为一个好的java工程师的话,还是需要非常好的掌握线程池这个知识的,其实很多问题都是因为我们没有用好线程池,所导致的...

线程池总体来讲有两个好处:第一个是可以复用我们的每一个线程;第二个就是可以控制我们资源的总量。

如果不用线程池会怎么样? 如果不使用线程池,每来一个任务就新开一个线程,

package threadpool;
/**
 * 每一个任务创建一个线程
 */
public class ForLoop {
    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            Thread thread = new Thread(new Task());
            //启动线程
            thread.start();}}

    static class Task implements Runnable {
        @Override
        public void run() {
            System.out.println("执行了方法");}}}

为什么说这是一种笨拙的方法?  因为我们对于java语言而言,每一个java中的线程会直接对应到操作系统中的线程,这样一来相当是在操作系统中创建了1000个线程,这个会带来很大的开销,线程的生命周期的开销是非常高的,线程的创建和销毁不是没有代价的,它希望我们jvm和操作系统提供一些辅助操作,在这种大量线程创建的时候,会消耗很多的资源,尤其是内存,而且这些线程创建之后还需要被回收,又会给垃圾回收器带来压力,并且我们系统、包括程序所创建线程是有上限的,从1000变到20万该怎么办,任务数量是不受我们控制的,但是线程数量是有上限的。所以我们就知道了有任务过来,不是每一个任务都需要或者有必要去新建一个线程来执行的。  这就是我们为要使用线程池的原因
    
实际tomcat等服务器也是用线程池来实现的
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028113655278.png" alt="image-20221028113655278" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114027647.png" alt="image-20221028114027647" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114214587.png" alt="image-20221028114214587" style="zoom:50%;" />



#### 线程增减的时机

##### 创建和停止线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028164825816.png" alt="image-20221028164825816" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165009181.png" alt="image-20221028165009181" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165359766.png" alt="image-20221028165359766" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028171041448.png" alt="image-20221028171041448" style="zoom:50%;" />

```
Current size最大能扩展到Max pool size
```

#### 添加线程规则

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172347027.png" alt="image-20221028172347027" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172648806.png" alt="image-20221028172648806" style="zoom:50%;" />

```
烧烤店里边有五张桌(5个核心线程),客人来了里边人没满就会往里边坐。当客人来了,里边满人了就会拓展店外边————外边新增5张桌子(最大线程数是5+5=10)。当收摊的时候,外边五张桌子会被收回来,而原本在里边的桌子始终存在。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028173448882.png" alt="image-20221028173448882" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174924714.png" alt="image-20221028174924714" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174946961.png" alt="image-20221028174946961" style="zoom:50%;" />



#### 线程存活时间和工作队列

##### keppAliveTime

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175400995.png" alt="image-20221028175400995" style="zoom:50%;" />

##### ThreadFactory 用来创建线程的

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175535761.png" alt="image-20221028175535761" style="zoom:50%;" />



##### 工作队列

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028223857757.png" alt="image-20221028223857757" style="zoom:50%;" />

```
直接交换:存不下任务的,注意 maxSize可能要设置大一些,
无界队列:不会被塞满。可以防止流量突增,但是有风险处理速度跟不上任务提交的速度,越积越多可能会造成内存浪费或者oom异常
有界队列:可以设置队列大小,,
```



#### 自动创建线程池的风险

##### 线程池应该手动创建还是自动创建?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028222308192.png" alt="image-20221028222308192" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028225136828.png" alt="image-20221028225136828" style="zoom:50%;" />

```java
//演示了这种newFixedThreadPool带来的一种可能出错的情况,这就意味着我们用这种固定的数量的线程池还是要额外注意的,,
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示newFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM {
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executorService.execute(new SubThread());
        }}}

class SubThread implements Runnable{
    @Override
    public void run() {
        try {
            //这个任务的特点就是一直在睡觉。因为不想这个任务被执行完毕,因为被执行完毕之后,这个任务就结束了进入下一个任务,
            // 我们的目标是把这个队列塞满,随着时间增加,队列里的任务越来越多才可能触发OOM错误
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();}}}
```



#### 常用线程池的用法表示

##### newSingleThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230213227.png" alt="image-20221028230213227" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 简单的线程池,这个线程池里只有一个固定的线程,
 */
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());
        }}}
```



##### CacheThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230413476.png" alt="image-20221028230413476" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CacheThreadPool {
    public static void main(String[] args) {
        //线程几乎是可以无限创建的,如果线程数量特别多任务数量特别多,也有可能会导致oom,
        ExecutorService executorService = Executors.newCachedThreadPool();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());}}}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028231651595.png" alt="image-20221028231651595" style="zoom:50%;" />



##### ScheduledThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduleThreadPoolTest {
    public static void main(String[] args) {
        //
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        //这里的放任务和刚才的不太一样
        threadPool.schedule(new FixedThreadPoolTest.Task(), 3, TimeUnit.SECONDS); //延迟3秒才执行 TimeUnit.SECONDS是指定单位为秒

        //以一定频率重复运行,(开始时间是1秒后,然后是隔3秒运行一次,)
        threadPool.scheduleAtFixedRate(new FixedThreadPoolTest.Task(), 1, 3, TimeUnit.SECONDS);
    }}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221029004544354.png" alt="image-20221029004544354" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221029011647545.png" alt="image-20221029011647545" style="zoom:50%;" />



#### 对比各种线程池的特点

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030233634878.png" alt="image-20221030233634878" style="zoom: 50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030234236113.png" alt="image-20221030234236113" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030234614951.png" alt="image-20221030234614951" style="zoom:50%;" />

```
1.因为FixedThreadPool和SingleThreadExecutor核心线程数和最大线程数都是被确定的,就需要这个无限队列来容纳任务数,
2.CachedThreadPool是来一个任务就创建一个线程
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031001148928.png" alt="image-20221031001148928" style="zoom:50%;" />

```
workStealingPool不保证执行顺序.不是那么常用
```



#### 如何正确关闭线程池

##### 停止线程池的正确方法

```
shutdown(); 方法并不是一上来就把所有线程任务就停止了,而是会拒绝后续提交的错误并抛出异常,并没有完全停止,

isTerminated(); 里面的线程包括正在执行的任务、包括队列里的任务都清空了才会返回true
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031130335366.png" alt="image-20221031130335366" style="zoom: 33%;" />

```java
package threadpool;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class ShuntDown {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ShuntDownTask());}

        Thread.sleep(1500);
        //shutdownNow() 的威力是比较大的,列队内的还没来得及执行的任务则会被返回(runnableList)[一般会做进一步的处理,比如记录或者是重新执行]
        List<Runnable> runnableList = executorService.shutdownNow();
        System.out.println(runnableList.toString());
//        executorService.shutdown();
//        //这3秒钟会阻塞并返回一个布尔值。(三秒钟之内没有没有完全停止,还没有停止就打印false)
//        boolean b = executorService.awaitTermination(7, TimeUnit.SECONDS);
//        System.out.println(b);
//        System.out.println((executorService.isShutdown()));
//        executorService.shutdown(); //这里用了 shutdown,后面再加入任务就会报错 RejectedExecutionException
//        executorService.execute(new ShuntDownTask());
//        System.out.println((executorService.isShutdown()));
//        System.out.println("isTerminated: "+executorService.isTerminated());
//        Thread.sleep(9000);
//        System.out.println("isTerminated: "+executorService.isTerminated());
    }

    static class ShuntDownTask implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(500);
                System.out.println(Thread.currentThread().getName());
            } catch (InterruptedException e) {
                //在睡眠期间假设有中断信号过来,会抛出这个异常
//                e.printStackTrace();
                System.out.println(Thread.currentThread().getName()+"被中断了");}}}}
```



#### 暂停和恢复线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031130846522.png" alt="image-20221031130846522" style="zoom: 50%;" />

```java
拒绝时机1:
executorService.shutdown(); //这里用了 shutdown,后面再加入任务就会报错 RejectedExecutionException
executorService.execute(new ShuntDownTask());
```

##### 4钟拒绝策略

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031132654562.png" alt="image-20221031132654562" style="zoom:33%;" />

```
四种拒绝策略:
AbortPolicy  (直接抛出一个异常,说明没有提交成功)
DiscardPolicy  (默默地把任务丢弃,不会得到通知,所以你也不知道这个任务不会得到处理)
DiscareOldestPolicy  (最老的、存在时间最久的任务丢弃掉)
CallerRunsPolicy  (谁提交的这个任务,谁就帮我去跑。比如主线程给线程池提交任务,线程池真的没有办法容纳了,它已经饱和了,那么这个时候就会让这个主线程————也就是提交任务的这个线程去执行,比较聪明的策略)

评价:第四种是无损的会让呼叫者线程去执行,1.避免避免了业务损失  2.可以让我们提交的速度降低下来,这是一种负反馈:比如主线程一直提交任务,但采用这种拒绝策略会让主线程自己去执行该任务(线程池已满返回给主线程执行),当主线程执行这些任务的时候也给了线程池的缓冲时间,

```

##### 钩子方法,给线程加点料

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031132929249.png" alt="image-20221031132929249" style="zoom:33%;" />

```
可以在每个任务执行之前和之后做一些事情,比如说日志或者说统计都可以
```

```
线程池利用了钩子函数拥有了暂停和恢复的能力
```

```java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 可暂停的线程池。演示每个任务执行前后放钩子函数  (钩子函数在设计模式中也是经常会被用到的)
 */

//继承于普通的线程池
public class PausableThreadPool extends ThreadPoolExecutor {

    //标记位。就是用来标记该线程是不是现在处于暂停状态的,,,,
    private boolean isPaused;
    //为了让这个布尔值的并发修改是安全的,我们给它上一把锁
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unPaused = lock.newCondition();


    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    //钩子函数登场,实际上是一个重写的方法。
    // 在每一次执行这个任务之前都会调用这个函数并且在这个函数中它会去检查 isPaused是不是想暂停了,如果是会让当前这个线程暂停,而不再继续执行 unPaused.await();
    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try {
            //在方法内部做一个检测:如果确实是true,说明我们确实想让它暂停
            while (isPaused) {
                unPaused.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            //解锁
            lock.unlock();
        }
    }

    //暂停方法
    private void pause() {
        //在这里锁住之后,我们运用这样的锁锁住之后,一定要记得这样的锁一定要用try catch finally,否则可能会出现这个锁永远不释放的情况,
        lock.lock();
        try {
            isPaused = true;
        } finally {
            lock.unlock();
        }
    }

    //恢复函数
    public void resume() {
        lock.lock();
        //把之前暂停的去唤醒
        try {
            isPaused = false;
            unPaused.signalAll(); //唤醒全部的方法
        } finally {
            lock.unlock();
        }
    }


    public static void main(String[] args) {
        PausableThreadPool pausableThreadPool = new PausableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>());
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("被执行了");
                try{
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        for (int i = 0; i < 1000; i++) {
            pausableThreadPool.execute(runnable);
        }
        try {
            Thread.sleep(1500);
            pausableThreadPool.pause();
            System.out.println("线程池被暂停了");
            Thread.sleep(1500);
            pausableThreadPool.resume();
            System.out.println("线程池被恢复了");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } }}
```



#### 线程池实现复用的原因

##### 实现原理、源码分析

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223535412.png" alt="image-20221031223535412" style="zoom: 33%;" />

```
idea Structure模块,感觉太实用了,可以看到该接口下的所有方法,并且提供了点击定位和看到返回值
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031222032761.png" alt="image-20221031222032761" style="zoom:50%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223622662.png" alt="image-20221031223622662" style="zoom:33%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223650002.png" alt="image-20221031223650002" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223725951.png" alt="image-20221031223725951" style="zoom:50%;" />



#### 线程池状态和使用注意点

##### 线程池状态

```
线程有状态,线程池也有状态
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223845121.png" alt="image-20221031223845121" style="zoom: 40%;" />

```
接着就是讲解源码的阶段 ....

使用线程池的注意点  第三点是线程始终结束不了会产生严重后果
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031230350793.png" alt="image-20221031230350793" style="zoom:50%;" />



#### 课程总结





### 第2节 ThreadLocal

#### ThreadLocal章节介绍

##### ThreadLocal 详解——这一次彻底掌握

```
非常重要的工具类 ThreadLocal
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031231306337.png" alt="image-20221031231306337" style="zoom:40%;" />

#### ThreadLocal的两种典型应用场景

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101214841152.png" alt="image-20221101214841152" style="zoom:40%;" />

#### 第一种典型场景

```
强调的是 每个Thread内有自己的实例副本,不共享
例子:如果班上30个同学只有一本教材,大家又想使用这本教材的话,那么很有可能就是说会抢着看的同时会可能抢着做笔记,那么自然就会发生线程安全的问题,就是并发的读写会带来数据不一致。而用来TreadLocal,旧等于是把这本教材去复印了30份,这样每个人都使用自己的书这样就不会出问题了。而这里的每一本书,每一个实例都只能用当前那个Thread当前的那个线程访问到,并且使用,其他线程是访问不到的,这也是ThreadLocal名字的由来,TreadLocal 线程本地,想表达的内容是这个副本只能被我这个线程本人本地所使用,其他线程是没有办法访问的,不是共用的,这样也不存在多线程的共享问题,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101221654828.png" alt="image-20221101221654828" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102000702844.png" alt="image-20221102000702844" style="zoom:40%;" />



#### SimpleDateFormat的进化之路

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 两个线程打印日期
 */

public class ThreadLocalNormalUsage00 {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                String date = new ThreadLocalNormalUsage00().date(9000);
                System.out.println("000  :"+date);}
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                String date = new ThreadLocalNormalUsage00().date(700);
                System.out.println("001  :"+date);
            }
        }).start();}

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时,,,::::
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 十个线程打印日期
 */

public class ThreadLocalNormalUsage01 {
    public static void main(String[] args) {
        for (int i = 0; i < 30; i++) {
            int finalI  =i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage01().date(finalI);
                    System.out.println("time:  " + date);
                }
            }).start();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();}}}

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 1000个打印日期的任务,用线程池来执行
 */

public class ThreadLocalNormalUsage02 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage02().date(finalI);
                    System.out.println("time:  " + date);
                }});}
        threadPool.shutdown();
    }

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 1000个打印日期的任务,用线程池来执行  (只新建一次 SimpleDateFormat。但是问题也出现了.会产生线程安全问题)
 */

public class ThreadLocalNormalUsage03 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);
    //只新建一次 SimpleDateFormat (能解决重复创建对象、浪费资源的问题)
    //但问题也随之出现 打印了两个 1970-01-01 08:15:33 为什么会出现这种问题? [所有线程都共用一个simpleDateFormat对象。发生了线程安全问题]
    static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage03().date(finalI);
                    System.out.println("time:  " + date);
                }});}
        threadPool.shutdown();}

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 1000个打印日期的任务,用线程池来执行。 加锁来解决线程安全问题 (用synchronized加锁)
 */

public class ThreadLocalNormalUsage04 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);
    //只新建一次 SimpleDateFormat (能解决重复创建对象、浪费资源的问题)
    //但问题也随之出现 打印了两个 1970-01-01 08:15:33 为什么会出现这种问题? [所有线程都共用一个simpleDateFormat对象。发生了线程安全问题]
    static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage04().date(finalI);
                    System.out.println("time:  " + date);
                }});}
        threadPool.shutdown();}

    public String date(int seconds) {
        Date date = new Date(1000 * seconds);
        String s = null;
        //把危险的代码给加锁
        synchronized (ThreadLocalNormalUsage04.class){
            s = dateFormat.format(date);}
        return s;}}
```

```
synchronized 能解决线程安全问题,但是它有性能问题。 synchronized加锁保证的是在同一时刻不能有超过一个线程来运行这一段代码,这样的话,超过1000个线程它们运行起来就需要一个个排队了,这样效率是比较低的。在高并发的情境下一个一个排队显然不符合我们的预期。更好的解决方案是 ThreadLocal
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102153950844.png" alt="image-20221102153950844" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102163443809.png" alt="image-20221102163443809" style="zoom:40%;" />





#### 利用ThreadLocal完美解决问题

##### 更好的解决方案是使用ThreadLocal

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102155959792.png" alt="image-20221102155959792" style="zoom:40%;" />

```
synchronized 能解决线程安全问题,但是它有性能问题。ThreadLocal能解决性能问题。

上图线程池中有10个线程,理想状态是 用10个线程去运行1000个任务同时又避免synchronized带来的性能损耗问题。该怎么办法? 可以给每一个线程内部去使用一个 dateFormat,也就是在这边有10个线程,那么这边就创建10个dateFormat对象,这样既没有带来性能损耗,同时又避免了synchronized所带来的一直等待排队的性能问题,同时它也是性能安全的(每个线程内部都有自己独有的dateFormat对象)。


ThreadLocal兼顾了两大优点:第一点是线程安全的   第二点没有synchronized带来的性能问题,它是完全可以并行执行的,因为每个线程内都有自己的独享的对象,所以不同的线程之间不会相互共享,也就不会有线程安全问题
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 利用ThreadLocal,给每一个线程分配自己的dateFormat对象,保证了线程安全,高效利用内存,
 * {1000个打印日期的任务,用线程池来执行}
 */

public class ThreadLocalNormalUsage05 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage05().date(finalI);
                    System.out.println("time:  " + date);
                }
            });
        }
        threadPool.shutdown();
    }

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
//        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        //这里get方法拿到的dateFormat 正是initialValue所生成的对象
        SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal2.get();
        return dateFormat.format(date);
    }
}

class ThreadSafeFormatter{
    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>(){

        //这个函数是进行初始化用的
        @Override
        protected SimpleDateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        }
    };

    //用lambda表达式写法。 和 dateFormatThreadLocal 效果一样
    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal2 =
            ThreadLocal.withInitial(()->new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"));
}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102162556561.png" alt="image-20221102162556561" style="zoom:40%;" />



#### 第二种典型场景 part1

```
第二种典型场景和第一种典型场景是有所不同的。第二种场景是想避免我老是需要传递参数
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102163949690.png" alt="image-20221102163949690" style="zoom:50%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223139081.png" alt="image-20221102223139081" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223259662.png" alt="image-20221102223259662" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223341047.png" alt="image-20221102223341047" style="zoom:40%;" />

```
以上三种解决方案是层层递进的。但无论用什么都会对性能有所影响。还是得看ThreadLocal
```



#### 第二种典型场景 part2

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102230123793.png" alt="image-20221102230123793" style="zoom:50%;" />

```java
package threadLocal;

/**
 * 演示ThreadLocal用法2: 避免传递参数的麻烦
 */
public class ThreadLocalNormalUsage06 {
    public static void main(String[] args) {
        new Service1().process();
    }}

class Service1 {
    public void process() {
        User user = new User("王小美");
        //这里ThreadLocal的用法和第一种典型用法有些不一样,不用一开始就赋初始值
        UserContextHolder.holder.set(user);
        //这里调用Service2的方法
        new Service2().process();
    }}

class Service2 {
    public void process() {
        //由Service1拿到对象就够了,后面就不再需要创建对象或读取了。通过get可以直接拿到这个对象
        User user = UserContextHolder.holder.get();
        System.out.println("Service2: " + user.name);
        new Service3().process();
    }}

class Service3 {
    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service3: " + user.name);
    }}

class UserContextHolder {
    //在这边会同样把 ThreadLocal定义为静态的,这是因为我们需要在多个方法中直接取到它,,,
    public static ThreadLocal<User> holder = new ThreadLocal<User>();
}

class User {
    String name;

    public User(String name) {
        this.name = name;
    }}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102230318280.png" alt="image-20221102230318280" style="zoom:40%;" />

```
这两个对应不同的请求,由于它们并没有直接共享User对象,所以它们之间不会有线程安全问题。在整个第一个线程的整条链路中,它所拿到的都是"王小美",第二个拿到的都是王姐,所以用了ThreadLocal之后避免了synchronized同步,非常高效的实现了在不同的方法间共享对象的目标。
```



#### ThreadLocal的两个作用和好处

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102231046103.png" alt="image-20221102231046103" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102232012239.png" alt="image-20221102232012239" style="zoom:40%;" />

#### 根据共享对象的生成时机不同,选择initialValue或set来保存对象

```
有时候用initialValue,有时候用set,这是为什么该怎么选择?
	1.初始化时机完全受我们控制的,不受外界影响,用 initialValue
	2.对象生成时机可不由我们控制。 用set。(B比如拦截器拦截到传进来的参数再赋值)
,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102232329194.png" alt="image-20221102232329194" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102232534215.png" alt="image-20221102232534215" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102235940728.png" alt="image-20221102235940728" style="zoom:40%;" />



#### ThreadLocal的主要方法

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103202532531.png" alt="image-20221103202532531" style="zoom:40%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103203255441.png" alt="image-20221103203255441" style="zoom:40%;" />

```
注:如果set值进去就不需要initialValue()设置值了。 也就是说用set还是用initialValue()方法来给我们的值赋值,恰恰对应了两种经典的用法,,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103204646906.png" alt="image-20221103204646906" style="zoom:33%;" />

```java
//演示了用set赋值,用get获取set进去的值,以及remove后再set值
package threadLocal;

/**
 * 演示ThreadLocal用法2: 避免传递参数的麻烦
 */
public class ThreadLocalNormalUsage06 {
    public static void main(String[] args) {
        new Service1().process();}}

class Service1 {
    public void process() {
        User user = new User("王小美");
        //这里ThreadLocal的用法和第一种典型用法有些不一样,不用一开始就赋初始值
        UserContextHolder.holder.set(user);
        //这里调用Service2的方法
        new Service2().process();}}

class Service2 {
    public void process() {
        //由Service1拿到对象就够了,后面就不再需要创建对象或读取了。通过get可以直接拿到这个对象
        User user = UserContextHolder.holder.get();
        System.out.println("Service2: " + user.name);
        UserContextHolder.holder.remove(); //这里remove 之后,Service3就拿不到用户名了,会清空保存的对象
        UserContextHolder.holder.set(new User("陈小龙")); //remove之后还可以重新为user对象赋值
        new Service3().process();}}

class Service3 {
    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service3: " + user.name);}}

class UserContextHolder {
    //在这边会同样把 ThreadLocal定义为静态的,这是因为我们需要在多个方法中直接取到它,,,
    public static ThreadLocal<User> holder = new ThreadLocal<User>();}

class User {
    String name;
    public User(String name) {
        this.name = name;}}
```



#### 图解ThreadLocal原理

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103210451114.png" alt="image-20221103210451114" style="zoom:40%;" />

```
同一个线程,同一个Thread它用ThreadLocalMap去保存不同的ThreadLocal,这是因为它很有可能会用到很多不同的ThreadLocal对象(比如一个线程下同时用simpleDate类和保存用户信息类),
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103212001418.png" alt="image-20221103212001418" style="zoom:40%;" />

```
注意:这个map以及map中的key和value都是保存在线程中的,而不是保存在ThreadLocal中 (ThreadLocalMap是保存在Thread中的,它是Thread类的成员变量),,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103213306791.png" alt="image-20221103213306791" style="zoom:40%;" />

##### ThreadLocalMap类

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103213825052.png" alt="image-20221103213825052" style="zoom:40%;" />

```
Entry[] tab = table;  Entry虽然类似于hashMap,但它在实现上会略有不同。比如在处理冲突的规则中,hashMap用的是拉链法,如果发生冲突我就用链表把它往下链,在JDK8中优化成这种如果发生冲突到一定量的时候就把它变成红黑树的形式,这是hashMap(红黑树和拉链法可以并存)

但是在ThreadLocalMap中会有所不同,它遇到冲突的时候,采用的是线性探测法,如果发生冲突就继续找下一个位置,而不是用链表拉链法,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103215535604.png" alt="image-20221103215535604" style="zoom:40%;" />

```
第一种运用场景适用于工具类。
第二种运用场景适用于拦截器
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103215823513.png" alt="image-20221103215823513" style="zoom:40%;" />



#### ThreadLocal的注意点

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103222416120.png" alt="image-20221103222416120" style="zoom:40%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103222219342.png" alt="image-20221103222219342" style="zoom:40%;" />

```java
class Service3 {
    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service3: " + user.name);
        //这里调用remove方法 保证能回收user这部分内存,避免内存泄露
        UserContextHolder.holder.remove();}}
```

##### 如何避免内存泄露(阿里规约)

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103222151344.png" alt="image-20221103222151344" style="zoom:50%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221103233522296.png" alt="image-20221103233522296" style="zoom:50%;" />

```java
package threadLocal;

/**
 * 演示空指针异常  NPE是空指针异常的缩写
 */
public class ThreadLocalNPE {
    ThreadLocal<Long> longThreadLocal = new ThreadLocal<Long>();

    public void set() {
        longThreadLocal.set(Thread.currentThread().getId());
    }

    /**
     * ThreadLocal<Long> longThreadLocal =new ThreadLocal<Long>(); 这里的泛型指定的是Long,
     * 包装类型的一个长整形。这里get()方法拿到的是一个包装类型Long[按ctrl看],
     * 而把对象类型Long转为基本类型long,由于这个对象本身是空,所以在这里转化的时候会形成空指针异常,
     * 并不是ThreadLocal的问题,我们ThreadLocal照常是返回[longThreadLocal.get();]一个null空,
     * 但是呢它并没有返回空指针异常,也就是如果我们在获取get的时候,如果提前没有进行赋值无论是用initialValue还是set都没有进行赋值的话,
     * 默认ThreadLocal是不会抛出空指针异常的,只不过会返回一个null而已。(转换不当才返回异常,装箱拆箱导致的)
     */
    public Long get() { //这里小写的long会报空指针异常。大写的Long 可以输出 null
        return longThreadLocal.get();
    }

    public static void main(String[] args) {
        ThreadLocalNPE threadLocalNPE = new ThreadLocalNPE();
        //没有任何人给它赋值,这里拿到的是一个空对象
        System.out.println("直接get: " + threadLocalNPE.get());
        //创建子线程
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                threadLocalNPE.set();
                System.out.println(threadLocalNPE.get());
            }
        });
        thread1.start(); }}
```

```java
Java中基本数据类型与包装类型有：

  基本类型  	  包装器类型  
boolean	Boolean
char	Character
int	Integer
byte	Byte
short	Short
long	Long
float	Float
double	Double
 

为什么存在这两种类型呢？

我们都知道在Java语言中，new一个对象存储在堆里，我们通过栈中的引用来使用这些对象；但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在栈中，因此更加高效。



有了基本类型为什么还要有包装类型呢？

我们知道Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。

二者相互转换:

1、int转Integer

int i = 0;  
Integer ii = new Integer(i);

2、Integer转int

Integer ii = new Integer(0);  
int i = ii.intValue();  


二者的区别：

1. 声明方式不同：
基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；
 
2. 存储方式及位置不同：
基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；
 
3. 初始值不同：
基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；
 
4. 使用方式不同：
基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。

```



#### ThreadLocal总结

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104105736166.png" alt="image-20221104105736166" style="zoom:40%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104110907977.png" alt="image-20221104110907977" style="zoom:40%;" />

```java
使用ThreadLocal带来的4点好处:
1.线程安全
2.不需要加锁,提高执行效果(效率高)
3.更高效地利用内存、节省开销
4.免去传参的繁琐
    
ThreadLocal的四个主要方法:
1. T initialValue()  作用是设置初始值,但它是延迟加载的,它只有在我们get的时候才会触发。如果我们之前调用了set(),那么initialValue()就不会触发,这两者是二选一的关系。通常这个方法只会被调用一次,除非remove()。 不重写默认返回null
2. void set(T t) 对于set()而言,它的作用是设置新值,,,
3.T get() 是拿到之前set进去的值
4. void remove() 方法是删除这个 ThreadLocal所对应的值。但是它只会删除自己这个ThreadLocal的,其他ThreadLocal不受影响的
    
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104110830238.png" alt="image-20221104110830238" style="zoom:40%;" />



### 第3节 分布式基础

#### 分布式章节介绍

```
比如说像搜索引擎,电商，微博,微信,O2O平台等等,凡是涉及到大规模用户,高并发访问的一般来讲是需要分布式来解决问题的,那么关于分布式系统实际上没有一个标准的答案...
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104112207283.png" alt="image-20221104112207283" style="zoom:40%;" />



#### 什么是分布式?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104125729955.png" alt="image-20221104125729955" style="zoom:40%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104131755967.png" alt="image-20221104131755967" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104131705293.png" alt="image-20221104131705293" style="zoom:40%;" />



#### 分布式的作用

##### 为什么需要分布式

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104132404441.png" alt="image-20221104132404441" style="zoom:40%;" />

###### 单体应用的问题 (不好之处)

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104132536082.png" alt="image-20221104132536082" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104132640795.png" alt="image-20221104132640795" style="zoom:40%;" />

```
这些单体应用的问题以及它的痛点就是我们为什么要分布式的非常好的理由

分布式的好处:
1.增大系统容量  因为我们一台机器肯定是满足不了我们用户的需求,用分布式给它拆分之后提高我们可以处理的请求数。
2.加强系统可用  因为我们之前的哪种模式,如果机器挂了的话,那会导致所有的模块都挂了,因为它整个是一个系统,可是我们用来分布式之后,比如说某一个模块挂了或者是某一台机器挂了这个不影响整体。
3.因为模块化,所以系统模块重用度更高
4.因为软件服务模块被拆分,开发和发布速度可以并行而变得更快 (一个项目比较大发布时间要10分钟,现在拆做五个模块并行发布只需要2分钟就行),,,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104134008150.png" alt="image-20221104134008150" style="zoom:33%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104134029722.png" alt="image-20221104134029722" style="zoom:40%;" />



#### 单体和分布式的对比

##### 分布式的好处

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104134159910.png" alt="image-20221104134159910" style="zoom:40%;" />

<hr/>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104134435530.png" alt="image-20221104134435530" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104134835166.png" alt="image-20221104134835166" style="zoom:40%;" />



#### CAP定理 (重要)

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104230314310.png" alt="image-20221104230314310" style="zoom:40%;" />

```
分区容错是 P
一致性是   C
可用性是   A
```

##### 1.CAP的重要性

```
CAP它是我们分布式系统设计中最基础也最为关键的理论,它实际上主要想表达一个什么问题呢?  它是说我们分布式不可能同时去满足三个条件。这三个条件就是我们介绍的C A P,那也就是说最多是三选二。,,,
```

##### 2.CAP理论是什么

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104231019803.png" alt="image-20221104231019803" style="zoom:40%;" />

```
P(Partition tolerance) 可以理解为网络错误(分区容错性不好理解)

这边有一个内容,你那边得不到这个内容,因为通信断了,这就是分区容错性
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104231530938.png" alt="image-20221104231530938" style="zoom:40%;" />

##### 3.分区容错

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104231731393.png" alt="image-20221104231731393" style="zoom:40%;" />

```
一旦发生错误,G1想发信息给G2,G2收不到,这就代表分区容错。一般而言,分区容错是无法避免的,所以我们可以认为分区容错里这个P,它在CAP里面它是一定存在的,这是一个客观事实
```

##### 4，一致性  C,Consistency

```
一致性就是说,我一个内容被改变之后,第二个能读到我这一次改变,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104232524590.png" alt="image-20221104232524590" style="zoom:40%;" />

##### 5.可用性  A,Availability

```
因为如果一致性没有办法保证的话,它就没办法拿到最新的数据,但是它能返回一个旧的数据,这依然代表它是一个可用的,只不过没有一致性而已
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104232636656.png" alt="image-20221104232636656" style="zoom:50%;" />



##### 6.CAP怎么选择

```
具体应用场景:

火车票   必须要满足一致性。 (无论是哪个终端去请求,每时每刻都必须是准确无误的。避免两个人买到同一张票)

银行转账  所以是可用性?  数据要绝对的可靠
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104234303584.png" alt="image-20221104234303584" style="zoom:40%;" />

```
CP一致性 或者 AP可用性

在什么场合,可用性高于一致性?  同步网页的时候,能看到网页就行,是不是最新的网页无所谓

在什么场合,可用性高于一致性?  支付的情况下,支付一定要保持一致,可以允许暂时的不可用

业务场景需要什么,就去选择
```



#### 分布式基础总结

##### 集群、分布式、微服务的区别

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104234627488.png" alt="image-20221104234627488" style="zoom:50%;" />

```

集群比如说有五台机器,这五台机器之间甚至可以相互没有通信都没有问题。 但如果是分布式的话,那么你个个机器之间必须要有通信,他们要相互协同工作。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221104235423215.png" alt="image-20221104235423215" style="zoom:50%;" />

```

集群:把同一个单体应用部署到多台机器上
微服务有一个非常显著的特点:就是它把各个模块给拆分之后,把能力给分散出去了.比如你这个服务只负者这件事,那个服务又只负责那个模块。所以集群它是把压力通过复制机器的方式给分散出去,而微服务是把能力拆分,所以他们区别是很大的。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221105000221170.png" alt="image-20221105000221170" style="zoom:50%;" />

```
微服务和分布式的区别是: 微服务是一种架构设计方式,也就是我把一个大的服务拆解成一个个小的服务,每个服务只对应一个功能只做一件事,可以独立部署,服务之间通过一些通信去调用,每个服务都独立开发、测试。这是一个微服务的概念。
而分布式它主要强调的是 一种部署的方式。

一个是架构和系统的设计模式
一个是部署这方面的内容(机器和机器之间会遇到哪些通信上的问题,时间上的不一致,顺序上的协调,如何容错,它要考虑的是实际部署之后,机器之间的物理的架构。而微服务是在此之前的一个逻辑上的架构。所以说做架构设计的时候,会先做逻辑架构再去做物理架构。微服务都是通过分布式去部署的
```



### 第4节  Docker应用

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221105223227199.png" alt="image-20221105223227199" style="zoom:50%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221105223315266.png" alt="image-20221105223315266" style="zoom:50%;" />



#### docker是什么

##### Docker的基本概念、用途、核心思想

###### docker应用广泛

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221105223631350.png" alt="image-20221105223631350" style="zoom:40%;" />

##### docker是什么?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221105224159634.png" alt="image-20221105224159634" style="zoom:40%;" />

```
也就是说,我们可以把任何想要的程序及其环境打包到我们的docker里,这个就是docker最主要的功能,,,
```



#### 为什么需要docker

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221105232141141.png" alt="image-20221105232141141" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221106225232892.png" alt="image-20221106225232892" style="zoom:40%;" />



#### docker的用途

```
docker的一大用途: 因为我们有了哪些标准化的程序之后,不管在什么机器上,不管要运行什么服务,我们都有这个标准的方式直接下载过来就能启动起来,所以在每台机器上,我们执行一两条命令就可以让程序正常跑起来
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221106231236427.png" alt="image-20221106231236427" style="zoom:50%;" />



#### docker的特点

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107220956593.png" alt="image-20221107220956593" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107221038006.png" alt="image-20221107221038006" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107221210053.png" alt="image-20221107221210053" style="zoom:40%;" />

```
另外也降低了我们的风险,因为我们这些程序最终会在同一个镜像内去运行,这样的话测试的时候测了一个就相当于百个。创建了一个docker镜像然后去测试,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107221318721.png" alt="image-20221107221318721" style="zoom:40%;" />



#### image镜像

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107221957866.png" alt="image-20221107221957866" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107223149795.png" alt="image-20221107223149795" style="zoom:40%;" />



```
linux 联合文件系统,一种分层的文件系统,它可以把不同的目录,去挂到一个虚拟的文件系统下。

镜像分为几层是可以自己控制的

linux 联合文件系统构建的时候是一层一层的并且每一层构建好之后,下面一层不再变化而在上面一层是以下面一层作为基础的,最终多层去组成了整体的文件系统,,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107223627136.png" alt="image-20221107223627136" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107223712473.png" alt="image-20221107223712473" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221107223907290.png" alt="image-20221107223907290" style="zoom:40%;" />

#### 容器和仓库

##### 容器

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221109215904191.png" alt="image-20221109215904191" style="zoom:40%;" />

##### 镜像仓库

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221109215943974.png" alt="image-20221109215943974" style="zoom:40%;" />

```
https://c.163.com/hub#/home
https://hub.docker.com/
```

##### client和deamon

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221109220519225.png" alt="image-20221109220519225" style="zoom:40%;" />



#### docker在Mac OS和Windows下的安装

```
https://www.docker.com/
直接安装就行
```

#### 更换系统镜像

```
老师是在原来服务器的基础上更换centos 镜像。而我直接在云服务上安装docker就行

window 登录云服务 
ssh root@175.178.91.105
```

####  docker在Linux下的安装

```
查看centos 版本    cat /etc/redhat-release
```

```java
首先把下载docker的地址换成国内的地址,这样速度会快很多

配置国内yum源
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
[/etc/yum.repos.d/CentOS-Base.repo 是放到指定的目录下]

yum clean all  把原来的软件源清理掉

安装所需的软件包
yum install -y yum-utils \device-mapper-persistent-data \lvm2


使用以下命令来设置稳定的存储库。  sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

查看docker版本
yum list docker-ce --showduplicates | sort -r

Docker 是服务器----客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动     systemctl start docker

安装完成后，运行下面的命令，验证是否安装成功。
docker version
或者
docker info
```



#### 第一个Docker容器

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221110222701106.png" alt="image-20221110222701106" style="zoom:40%;" />

```
拉取 hello-world
docker pull hello-world

查看docker 镜像   docker images

运行镜像 docker run images
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221110223931566.png" alt="image-20221110223931566" style="zoom:40%;" />

#### 后台运行容器

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111105843206.png" alt="image-20221111105843206" style="zoom:40%;" />

```
将nginx镜像从网易云拉取下来
hub.c.163.com/library/nginx:latest

运行 docker run hub.c.163.com/library/nginx

可以看到容器所对应的镜像等具体情况  docker ps 

ctrl+c可以退出nginx容器运行状态 (无效时可以使用 docker stop 容器id)

如何让nginx后台运行  docker run -d hub.c.163.com/library/nginx 

查看/访问容器的内部  docker exec -it 8417 bash [通常访问容器内部是以命令行的方式,所以在这里利用我们的shell也就是终端去进去, -i代表让容器输入有效, t是给我们分配一个终端。-it合起来的含义就是把容器内部的终端映射到我们当前这个终端,这样的话,我们在这个窗口输入的命令就会到那边去,所以it是通常都会加的配置。8417是指代容器id,容器少的话打一个8也行。  bash代表我们要启动终端]
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111105937432.png" alt="image-20221111105937432" style="zoom:50%;" />



#### 访问nginx容器

##### docker的网络模式

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111111901327.png" alt="image-20221111111901327" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111114637823.png" alt="image-20221111114637823" style="zoom:50%;" />

```java
docker的隔离性是它的很大的一大个特点,同时它的网络也是隔离的,这意味着你在里面运行的网络,那你在外边是体会不到的,比如它在里面80端口起了一个服务,那这是它内部的事情,他不会自动的就映射到外面宿主机的80端口,,,

那怎么对里面的网络进行感知?  那这个时候就需要用到 我们的网络配置了,配置好之后,就可以让它们进行端口的映射      
最常用的是桥接网络。 通过桥使宿主机与容器内部进行通信,,
Host, 去和主机使用同一个网络,如果采用host模式,容器不会虚拟出自己的网卡,ip等,而是直接使用宿主机上的

端口映射: 比如在里面我们启动的是 80端口,外面的80端口可能被占用了,但我们依然对里面的80端口进行访问,那就需要做一个其他的映射映射,比如里面是80,我想映射到外面的8080

docker run -d -p 8080:80 hub.c.163.com/library/nginx
在本机的8080端口去映射到容器内部的80端口  

放行8082端口 访问http://175.178.91.105:8082/ 即可

docker run -d -P hub.c.163.com/library/nginx 如果是-P的话会将容器的所有端口进行映射(随机端口)
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111113502290.png" alt="image-20221111113502290" style="zoom:50%;" />



#### dockerfile实战

```
制作自己的Docker容器
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111162226020.png" alt="image-20221111162226020" style="zoom:40%;" />

```
alpine 是专门针对docker来做的一个极小型的linux环境

FROM alpine:latest
MAINTAINER wei
CMD echo 'hello my docker, this is wei'

docker build  -t hello_docker .命令就是根据一个dockerfile来制作镜像的。-t是指定镜像名字。这个.点的含义就是Dockerfile所在的路径,点就代表当前的路径,所以打.点就能让它找到Dockerfile

docker run hello_docker 最后是运行
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111164426163.png" alt="image-20221111164426163" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111164333895.png" alt="image-20221111164333895" style="zoom:50%;" />

#### 总结docker





### 第五节 Nginx

#### Nginx章节介绍

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111165704209.png" alt="image-20221111165704209" style="zoom:40%;" />



#### Nginx的适用场景

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111165915870.png" alt="image-20221111165915870" style="zoom:40%;" />

##### Nginx是什么、适用场景

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111170102848.png" alt="image-20221111170102848" style="zoom:40%;" />

###### HTTP的反向代理服务器

什么是正向代理?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111170240932.png" alt="image-20221111170240932" style="zoom:40%;" />

```
直接访问网络、银行或者文件不就可以了吗?为什么要加一个代理服务器?  其实代理服务器的一个典型作用就是提供安全功能。如图中画的一般 代理服务器有一个防火墙,有了这个防火墙,原本客户端所不具备的那些安全检测的功能都可以通过代理服务器来实现而且有了代理服务器之后我们还可以隐藏自身的信息————比如后面会有100个客户端,但是对于响应服务器这边的百度来讲,它看不到我们这边的100个客户端,它只能看到中间的代理服务器,所以就进一步的保护了我们的隐私。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111171224199.png" alt="image-20221111171224199" style="zoom:40%;" />

```
什么是反向代理?
对于我们而言,反向代理之所以接触的比较少,是因为反向代理通常是位于服务端中服务开发的,而不是我们上网所使用到的,所以通常情况下我们不是一个java开发者,很少会接触到反向代理。
反向代理是指我们这些客户端去访问的时候,不直接访问到所要请求的服务器,而是在这些服务器前面统一加一个服务器,这就叫做 反向代理。同样的这个服务器会把用户的请求进行合理的转发并且把返回的内容也进行合理的返回,让用户能正确的访问这些服务器。反向中的反就是针对于它的方向或者说它的定位而言,之前正向代理定位是给我们客户端用的,而现在的定位恰好反过来是给我们服务端用的;之前对于服务端来说,客户端的信息是看不到的,现在对于客户端而言,服务端信息是看不到的

为什么需要反向代理服务器?直接访问不可以吗   答:反向代理服务器除了刚才和正向代理服务器类似的功能(提供安全功能、提供防火墙功能之外),它有一个很重要的功能就是在后端多个服务器之间,提供负载均衡或者是对比较慢的服务器提供缓存。 通常网站压力大,就会部署多台服务器,如果我们直接访问某一台的话,那么这一台压力很大,其他台的服务器却感受不到流量,所以我们通过一个反向代理服务器,就可以把来自用户的请求压力进行平均分配,这就是负载均衡的概念,这样我们就可以充分利用服务器资源了。 也可以把常用的内容直接缓存到反向代理服务器,加快响应
这就是反向代理的很重要的两个作用分别是 负载均衡和缓存

```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111174153850.png" alt="image-20221111174153850" style="zoom:40%;" />

###### 正向代理+反向代理

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111174333844.png" alt="image-20221111174333844" style="zoom:40%;" />

```
动态静态资源分离

如果是静态资源服务器连tomcat都不用运行,而且Nginx性能还不错
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111175415342.png" alt="image-20221111175415342" style="zoom:40%;" />



#### Nginx的优点

##### Nginx应用广泛

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111224919171.png" alt="image-20221111224919171" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221111225615123.png" alt="image-20221111225615123" style="zoom:40%;" />

#### Nginx的安装

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221112111102652.png" alt="image-20221112111102652" style="zoom:40%;" />

```java
yum install yum-utils


然后查看源
yum list | grep nginx
看到存在稳定版的源，确认无误。



运行安装命令
yum install nginx 1:1.16.1-1.el7.ngx
过程中输入y，确认


查看版本，若出现版本号，则安装成功
nginx -v
用whereis nginx可以查看到目录：
nginx: /usr/sbin/nginx 
```



#### Nginx的常用命令

##### 常用命令的讲解和演示

```
启动Nginx /usr/bin/nginx  (启动之前可以先关闭 docker的Nginx  systemctl stop docker)

验证Nginx是否启动成功  1.可以再输入启动Nginx的指令 会提示端口占用 
ps -ef | grep nginx
netstat -ntlp   //查看当前所有tcp端口
netstat -ntulp | grep 80   //查看所有80端口使用情况
    
nginx -h 查看Nginx常用命令 

    
指定Nginx读取配置文件 nginx -c /etc/nginx/nginx.conf

关闭Nginx服务 nginx -s stop

nginx -t 检查配置文件有没有问题

nginx -v  只打印版本号
nginx -v  详细打印版本信息 

whereis nginx 查看nginx所在路径


```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221113152203664.png" alt="image-20221113152203664" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221113152247125.png" alt="image-20221113152247125" style="zoom:40%;" />

<hr>
<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221113152127146.png" alt="image-20221113152127146" style="zoom:40%;" />

#### 配置文件讲解

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114000217970.png" alt="image-20221114000217970" style="zoom:50%;" />

```
访问 175.178.91.105:80 看到的实际是在 /www/server/nginx/html/index.html中。

只要是在/www/server/nginx/html/这个文件下的文件,它都可以通过nginx去进行合理的转发并且访问,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221113235448130.png" alt="image-20221113235448130" style="zoom:70%;" />



#### 搭建静态资源服务器

```java
上传本地文件到服务器 (有中文好像不行?)
scp -r 本地文件地址 root@175.178.91.105:\www\server\nginx\web\

需要修改配置才能找到并显示该web文件下的文件
修改 vim /www/server/panel/vhost/nginx/0.default.conf  (宝塔面板中是这样)
server
{
    listen 80;
    server_name _;
    index index.html;
    root /www/server/nginx/web;
}

最后记得重启nginx (或者nginx -t 测试一下)
    
    
    access_log感觉挺有用的,可以记录用户访问网站的信息
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114004025964.png" alt="image-20221114004025964" style="zoom:50%;" />



#### 总结Nginx





### 第6节 消息队列RabbitMQ

#### RabbitMQ章节介绍

```
从MQ到RabbitMQ,比其他MQ有什么优势

RabbitMQ采用的是Erlang语言,安装之前要提前安装一些相应的环境
,,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114005821819.png" alt="image-20221114005821819" style="zoom:50%;" />



#### 初识消息队列

##### 初识RabbitMQ

```
邮局 ()
producer: 生产者    消息的生产者(信息的来源)
queue: 队列
consumer: 消费者    (对应邮局中的收件人)
,,,,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114153626595.png" alt="image-20221114153626595" style="zoom:40%;" />

##### 消息队列

```
MQ(Message Queue)  消息队列  
队列先进先出的一种数据结构
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114154011577.png" alt="image-20221114154011577" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114160434937.png" alt="image-20221114160434937" style="zoom:40%;" />

##### 为什么要用消息队列

```
系统解耦  (不需要关心消息队列具体做了什么,有结果返回就行)
异步调用  (区别于同步,更高效)
流量削峰  (可以把高峰的流量先存到消息队列中)
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114161127741.png" alt="image-20221114161127741" style="zoom:40%;" />

#### RabbitMQ的特点和核心概念

```
一款非常优秀的消息中间件
底层是使用Erlang语言编写的,Erlang语言最初是用于交换机领域有广泛应用的,在通讯领域比如思科是非常受欢迎的。这个语言有什么特性? 性能非常好,而且它在通信方面是有优势的,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114214430785.png" alt="image-20221114214430785" style="zoom:40%;" />

##### AMQP协议

```
AMQP协议  全称是 高级消息队列协议
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114214927094.png" alt="image-20221114214927094" style="zoom:40%;" />

##### RabbitMQ核心概念

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114215403296.png" alt="image-20221114215403296" style="zoom:40%;" />

```
virtual host可以看做是一个独立的单元
```

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114215711660.png" alt="image-20221114215711660" style="zoom:40%;" />

<hr>

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114215809001.png" alt="image-20221114215809001" style="zoom:40%;" />

##### 消息流转过程

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221114220028450.png" alt="image-20221114220028450" style="zoom:40%;" />

```
消息流转过程的重点在于  Exchange和Message Queue的绑定关系。在绑定的时候需要指定一个路由键(在生产者发送Message的时候需要指定该键),Exchange才能正确的发送给相应的Message Queue,而Consumer会监听Message Queue拿到信息后再进行后续的处理
```



#### RabbitMQ在Cent OS下的安装



