## 第30-31周_多线程与分布式

#### 多线程与分布式 周介绍

```
第五阶段主要包括 分布式与微服务相关的内容。

个人感受:感觉挺多新奇的、没有了解过的知识点,冲
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012237328.png" alt="image-20221028012237328" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012450782.png" alt="image-20221028012450782" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028012618434.png" alt="image-20221028012618434" style="zoom:50%;" />



### 第一节 线程池

#### 初识线程池

##### 初识线程池——治理线程的最大法宝

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028105746921.png" alt="image-20221028105746921" style="zoom:50%;" />

##### 线程池的自我介绍

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028110913536.png" alt="image-20221028110913536" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028112331999.png" alt="image-20221028112331999" style="zoom:50%;" />

```java
线程池为什么这么重要? 实际上如果我们想成为一个好的java工程师的话,还是需要非常好的掌握线程池这个知识的,其实很多问题都是因为我们没有用好线程池,所导致的...

线程池总体来讲有两个好处:第一个是可以复用我们的每一个线程;第二个就是可以控制我们资源的总量。

如果不用线程池会怎么样? 如果不使用线程池,每来一个任务就新开一个线程,

package threadpool;
/**
 * 每一个任务创建一个线程
 */
public class ForLoop {
    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            Thread thread = new Thread(new Task());
            //启动线程
            thread.start();}}

    static class Task implements Runnable {
        @Override
        public void run() {
            System.out.println("执行了方法");}}}

为什么说这是一种笨拙的方法?  因为我们对于java语言而言,每一个java中的线程会直接对应到操作系统中的线程,这样一来相当是在操作系统中创建了1000个线程,这个会带来很大的开销,线程的生命周期的开销是非常高的,线程的创建和销毁不是没有代价的,它希望我们jvm和操作系统提供一些辅助操作,在这种大量线程创建的时候,会消耗很多的资源,尤其是内存,而且这些线程创建之后还需要被回收,又会给垃圾回收器带来压力,并且我们系统、包括程序所创建线程是有上限的,从1000变到20万该怎么办,任务数量是不受我们控制的,但是线程数量是有上限的。所以我们就知道了有任务过来,不是每一个任务都需要或者有必要去新建一个线程来执行的。  这就是我们为要使用线程池的原因
    
实际tomcat等服务器也是用线程池来实现的
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028113655278.png" alt="image-20221028113655278" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114027647.png" alt="image-20221028114027647" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028114214587.png" alt="image-20221028114214587" style="zoom:50%;" />



#### 线程增减的时机

##### 创建和停止线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028164825816.png" alt="image-20221028164825816" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165009181.png" alt="image-20221028165009181" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028165359766.png" alt="image-20221028165359766" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028171041448.png" alt="image-20221028171041448" style="zoom:50%;" />

```
Current size最大能扩展到Max pool size
```

#### 添加线程规则

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172347027.png" alt="image-20221028172347027" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028172648806.png" alt="image-20221028172648806" style="zoom:50%;" />

```
烧烤店里边有五张桌(5个核心线程),客人来了里边人没满就会往里边坐。当客人来了,里边满人了就会拓展店外边————外边新增5张桌子(最大线程数是5+5=10)。当收摊的时候,外边五张桌子会被收回来,而原本在里边的桌子始终存在。
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028173448882.png" alt="image-20221028173448882" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174924714.png" alt="image-20221028174924714" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028174946961.png" alt="image-20221028174946961" style="zoom:50%;" />



#### 线程存活时间和工作队列

##### keppAliveTime

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175400995.png" alt="image-20221028175400995" style="zoom:50%;" />

##### ThreadFactory 用来创建线程的

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028175535761.png" alt="image-20221028175535761" style="zoom:50%;" />



##### 工作队列

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028223857757.png" alt="image-20221028223857757" style="zoom:50%;" />

```
直接交换:存不下任务的,注意 maxSize可能要设置大一些,
无界队列:不会被塞满。可以防止流量突增,但是有风险处理速度跟不上任务提交的速度,越积越多可能会造成内存浪费或者oom异常
有界队列:可以设置队列大小,,
```



#### 自动创建线程池的风险

##### 线程池应该手动创建还是自动创建?

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028222308192.png" alt="image-20221028222308192" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028225136828.png" alt="image-20221028225136828" style="zoom:50%;" />

```java
//演示了这种newFixedThreadPool带来的一种可能出错的情况,这就意味着我们用这种固定的数量的线程池还是要额外注意的,,
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示newFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM {
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executorService.execute(new SubThread());
        }}}

class SubThread implements Runnable{
    @Override
    public void run() {
        try {
            //这个任务的特点就是一直在睡觉。因为不想这个任务被执行完毕,因为被执行完毕之后,这个任务就结束了进入下一个任务,
            // 我们的目标是把这个队列塞满,随着时间增加,队列里的任务越来越多才可能触发OOM错误
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();}}}
```



#### 常用线程池的用法表示

##### newSingleThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230213227.png" alt="image-20221028230213227" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 简单的线程池,这个线程池里只有一个固定的线程,
 */
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());
        }}}
```



##### CacheThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028230413476.png" alt="image-20221028230413476" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CacheThreadPool {
    public static void main(String[] args) {
        //线程几乎是可以无限创建的,如果线程数量特别多任务数量特别多,也有可能会导致oom,
        ExecutorService executorService = Executors.newCachedThreadPool();

        for (int i = 0; i < 20; i++) {
            executorService.execute(new FixedThreadPoolTest.Task());}}}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028231651595.png" alt="image-20221028231651595" style="zoom:50%;" />



##### ScheduledThreadPool

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

```java
package threadpool;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduleThreadPoolTest {
    public static void main(String[] args) {
        //
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        //这里的放任务和刚才的不太一样
        threadPool.schedule(new FixedThreadPoolTest.Task(), 3, TimeUnit.SECONDS); //延迟3秒才执行 TimeUnit.SECONDS是指定单位为秒

        //以一定频率重复运行,(开始时间是1秒后,然后是隔3秒运行一次,)
        threadPool.scheduleAtFixedRate(new FixedThreadPoolTest.Task(), 1, 3, TimeUnit.SECONDS);
    }}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221028232202173.png" alt="image-20221028232202173" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221029004544354.png" alt="image-20221029004544354" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221029011647545.png" alt="image-20221029011647545" style="zoom:50%;" />



#### 对比各种线程池的特点

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030233634878.png" alt="image-20221030233634878" style="zoom: 50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030234236113.png" alt="image-20221030234236113" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221030234614951.png" alt="image-20221030234614951" style="zoom:50%;" />

```
1.因为FixedThreadPool和SingleThreadExecutor核心线程数和最大线程数都是被确定的,就需要这个无限队列来容纳任务数,
2.CachedThreadPool是来一个任务就创建一个线程
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031001148928.png" alt="image-20221031001148928" style="zoom:50%;" />

```
workStealingPool不保证执行顺序.不是那么常用
```



#### 如何正确关闭线程池

##### 停止线程池的正确方法

```
shutdown(); 方法并不是一上来就把所有线程任务就停止了,而是会拒绝后续提交的错误并抛出异常,并没有完全停止,

isTerminated(); 里面的线程包括正在执行的任务、包括队列里的任务都清空了才会返回true
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031130335366.png" alt="image-20221031130335366" style="zoom: 33%;" />

```java
package threadpool;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class ShuntDown {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ShuntDownTask());}

        Thread.sleep(1500);
        //shutdownNow() 的威力是比较大的,列队内的还没来得及执行的任务则会被返回(runnableList)[一般会做进一步的处理,比如记录或者是重新执行]
        List<Runnable> runnableList = executorService.shutdownNow();
        System.out.println(runnableList.toString());
//        executorService.shutdown();
//        //这3秒钟会阻塞并返回一个布尔值。(三秒钟之内没有没有完全停止,还没有停止就打印false)
//        boolean b = executorService.awaitTermination(7, TimeUnit.SECONDS);
//        System.out.println(b);
//        System.out.println((executorService.isShutdown()));
//        executorService.shutdown(); //这里用了 shutdown,后面再加入任务就会报错 RejectedExecutionException
//        executorService.execute(new ShuntDownTask());
//        System.out.println((executorService.isShutdown()));
//        System.out.println("isTerminated: "+executorService.isTerminated());
//        Thread.sleep(9000);
//        System.out.println("isTerminated: "+executorService.isTerminated());
    }

    static class ShuntDownTask implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(500);
                System.out.println(Thread.currentThread().getName());
            } catch (InterruptedException e) {
                //在睡眠期间假设有中断信号过来,会抛出这个异常
//                e.printStackTrace();
                System.out.println(Thread.currentThread().getName()+"被中断了");}}}}
```



#### 暂停和恢复线程池

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031130846522.png" alt="image-20221031130846522" style="zoom: 50%;" />

```java
拒绝时机1:
executorService.shutdown(); //这里用了 shutdown,后面再加入任务就会报错 RejectedExecutionException
executorService.execute(new ShuntDownTask());
```

##### 4钟拒绝策略

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031132654562.png" alt="image-20221031132654562" style="zoom:33%;" />

```
四种拒绝策略:
AbortPolicy  (直接抛出一个异常,说明没有提交成功)
DiscardPolicy  (默默地把任务丢弃,不会得到通知,所以你也不知道这个任务不会得到处理)
DiscareOldestPolicy  (最老的、存在时间最久的任务丢弃掉)
CallerRunsPolicy  (谁提交的这个任务,谁就帮我去跑。比如主线程给线程池提交任务,线程池真的没有办法容纳了,它已经饱和了,那么这个时候就会让这个主线程————也就是提交任务的这个线程去执行,比较聪明的策略)

评价:第四种是无损的会让呼叫者线程去执行,1.避免避免了业务损失  2.可以让我们提交的速度降低下来,这是一种负反馈:比如主线程一直提交任务,但采用这种拒绝策略会让主线程自己去执行该任务(线程池已满返回给主线程执行),当主线程执行这些任务的时候也给了线程池的缓冲时间,

```

##### 钩子方法,给线程加点料

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031132929249.png" alt="image-20221031132929249" style="zoom:33%;" />

```
可以在每个任务执行之前和之后做一些事情,比如说日志或者说统计都可以
```

```
线程池利用了钩子函数拥有了暂停和恢复的能力
```

```java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 可暂停的线程池。演示每个任务执行前后放钩子函数  (钩子函数在设计模式中也是经常会被用到的)
 */

//继承于普通的线程池
public class PausableThreadPool extends ThreadPoolExecutor {

    //标记位。就是用来标记该线程是不是现在处于暂停状态的,,,,
    private boolean isPaused;
    //为了让这个布尔值的并发修改是安全的,我们给它上一把锁
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unPaused = lock.newCondition();


    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }
    public PausableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    //钩子函数登场,实际上是一个重写的方法。
    // 在每一次执行这个任务之前都会调用这个函数并且在这个函数中它会去检查 isPaused是不是想暂停了,如果是会让当前这个线程暂停,而不再继续执行 unPaused.await();
    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try {
            //在方法内部做一个检测:如果确实是true,说明我们确实想让它暂停
            while (isPaused) {
                unPaused.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            //解锁
            lock.unlock();
        }
    }

    //暂停方法
    private void pause() {
        //在这里锁住之后,我们运用这样的锁锁住之后,一定要记得这样的锁一定要用try catch finally,否则可能会出现这个锁永远不释放的情况,
        lock.lock();
        try {
            isPaused = true;
        } finally {
            lock.unlock();
        }
    }

    //恢复函数
    public void resume() {
        lock.lock();
        //把之前暂停的去唤醒
        try {
            isPaused = false;
            unPaused.signalAll(); //唤醒全部的方法
        } finally {
            lock.unlock();
        }
    }


    public static void main(String[] args) {
        PausableThreadPool pausableThreadPool = new PausableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>());
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("被执行了");
                try{
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        for (int i = 0; i < 1000; i++) {
            pausableThreadPool.execute(runnable);
        }
        try {
            Thread.sleep(1500);
            pausableThreadPool.pause();
            System.out.println("线程池被暂停了");
            Thread.sleep(1500);
            pausableThreadPool.resume();
            System.out.println("线程池被恢复了");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } }}
```



#### 线程池实现复用的原因

##### 实现原理、源码分析

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223535412.png" alt="image-20221031223535412" style="zoom: 33%;" />

```
idea Structure模块,感觉太实用了,可以看到该接口下的所有方法,并且提供了点击定位和看到返回值
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031222032761.png" alt="image-20221031222032761" style="zoom:50%;" />



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223622662.png" alt="image-20221031223622662" style="zoom:33%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223650002.png" alt="image-20221031223650002" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223725951.png" alt="image-20221031223725951" style="zoom:50%;" />



#### 线程池状态和使用注意点

##### 线程池状态

```
线程有状态,线程池也有状态
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031223845121.png" alt="image-20221031223845121" style="zoom: 40%;" />

```
接着就是讲解源码的阶段 ....

使用线程池的注意点  第三点是线程始终结束不了会产生严重后果
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031230350793.png" alt="image-20221031230350793" style="zoom:50%;" />



#### 课程总结





### 第2节 ThreadLocal

#### ThreadLocal章节介绍

##### ThreadLocal 详解——这一次彻底掌握

```
非常重要的工具类 ThreadLocal
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221031231306337.png" alt="image-20221031231306337" style="zoom:40%;" />

#### ThreadLocal的两种典型应用场景

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101214841152.png" alt="image-20221101214841152" style="zoom:40%;" />

#### 第一种典型场景

```
强调的是 每个Thread内有自己的实例副本,不共享
例子:如果班上30个同学只有一本教材,大家又想使用这本教材的话,那么很有可能就是说会抢着看的同时会可能抢着做笔记,那么自然就会发生线程安全的问题,就是并发的读写会带来数据不一致。而用来TreadLocal,旧等于是把这本教材去复印了30份,这样每个人都使用自己的书这样就不会出问题了。而这里的每一本书,每一个实例都只能用当前那个Thread当前的那个线程访问到,并且使用,其他线程是访问不到的,这也是ThreadLocal名字的由来,TreadLocal 线程本地,想表达的内容是这个副本只能被我这个线程本人本地所使用,其他线程是没有办法访问的,不是共用的,这样也不存在多线程的共享问题,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221101221654828.png" alt="image-20221101221654828" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102000702844.png" alt="image-20221102000702844" style="zoom:40%;" />



#### SimpleDateFormat的进化之路

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 两个线程打印日期
 */

public class ThreadLocalNormalUsage00 {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                String date = new ThreadLocalNormalUsage00().date(9000);
                System.out.println("000  :"+date);}
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                String date = new ThreadLocalNormalUsage00().date(700);
                System.out.println("001  :"+date);
            }
        }).start();}

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时,,,::::
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 十个线程打印日期
 */

public class ThreadLocalNormalUsage01 {
    public static void main(String[] args) {
        for (int i = 0; i < 30; i++) {
            int finalI  =i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage01().date(finalI);
                    System.out.println("time:  " + date);
                }
            }).start();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();}}}

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 1000个打印日期的任务,用线程池来执行
 */

public class ThreadLocalNormalUsage02 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage02().date(finalI);
                    System.out.println("time:  " + date);
                }});}
        threadPool.shutdown();
    }

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 1000个打印日期的任务,用线程池来执行  (只新建一次 SimpleDateFormat。但是问题也出现了.会产生线程安全问题)
 */

public class ThreadLocalNormalUsage03 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);
    //只新建一次 SimpleDateFormat (能解决重复创建对象、浪费资源的问题)
    //但问题也随之出现 打印了两个 1970-01-01 08:15:33 为什么会出现这种问题? [所有线程都共用一个simpleDateFormat对象。发生了线程安全问题]
    static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage03().date(finalI);
                    System.out.println("time:  " + date);
                }});}
        threadPool.shutdown();}

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
        return dateFormat.format(date);}}
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 1000个打印日期的任务,用线程池来执行。 加锁来解决线程安全问题 (用synchronized加锁)
 */

public class ThreadLocalNormalUsage04 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);
    //只新建一次 SimpleDateFormat (能解决重复创建对象、浪费资源的问题)
    //但问题也随之出现 打印了两个 1970-01-01 08:15:33 为什么会出现这种问题? [所有线程都共用一个simpleDateFormat对象。发生了线程安全问题]
    static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage04().date(finalI);
                    System.out.println("time:  " + date);
                }});}
        threadPool.shutdown();}

    public String date(int seconds) {
        Date date = new Date(1000 * seconds);
        String s = null;
        //把危险的代码给加锁
        synchronized (ThreadLocalNormalUsage04.class){
            s = dateFormat.format(date);}
        return s;}}
```

```
synchronized 能解决线程安全问题,但是它有性能问题。 synchronized加锁保证的是在同一时刻不能有超过一个线程来运行这一段代码,这样的话,超过1000个线程它们运行起来就需要一个个排队了,这样效率是比较低的。在高并发的情境下一个一个排队显然不符合我们的预期。更好的解决方案是 ThreadLocal
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102153950844.png" alt="image-20221102153950844" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102163443809.png" alt="image-20221102163443809" style="zoom:40%;" />





#### 利用ThreadLocal完美解决问题

##### 更好的解决方案是使用ThreadLocal

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102155959792.png" alt="image-20221102155959792" style="zoom:40%;" />

```
synchronized 能解决线程安全问题,但是它有性能问题。ThreadLocal能解决性能问题。

上图线程池中有10个线程,理想状态是 用10个线程去运行1000个任务同时又避免synchronized带来的性能损耗问题。该怎么办法? 可以给每一个线程内部去使用一个 dateFormat,也就是在这边有10个线程,那么这边就创建10个dateFormat对象,这样既没有带来性能损耗,同时又避免了synchronized所带来的一直等待排队的性能问题,同时它也是性能安全的(每个线程内部都有自己独有的dateFormat对象)。


ThreadLocal兼顾了两大优点:第一点是线程安全的   第二点没有synchronized带来的性能问题,它是完全可以并行执行的,因为每个线程内都有自己的独享的对象,所以不同的线程之间不会相互共享,也就不会有线程安全问题
```

```java
package threadLocal;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 利用ThreadLocal,给每一个线程分配自己的dateFormat对象,保证了线程安全,高效利用内存,
 * {1000个打印日期的任务,用线程池来执行}
 */

public class ThreadLocalNormalUsage05 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalNormalUsage05().date(finalI);
                    System.out.println("time:  " + date);
                }
            });
        }
        threadPool.shutdown();
    }

    public String date(int seconds) {
        //参数的单位是毫秒,从1970.1.1 00:00:00  GMT计时
        Date date = new Date(1000 * seconds);
//        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        //这里get方法拿到的dateFormat 正是initialValue所生成的对象
        SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal2.get();
        return dateFormat.format(date);
    }
}

class ThreadSafeFormatter{
    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>(){

        //这个函数是进行初始化用的
        @Override
        protected SimpleDateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        }
    };

    //用lambda表达式写法。 和 dateFormatThreadLocal 效果一样
    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal2 =
            ThreadLocal.withInitial(()->new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"));
}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102162556561.png" alt="image-20221102162556561" style="zoom:40%;" />



#### 第二种典型场景 part1

```
第二种典型场景和第一种典型场景是有所不同的。第二种场景是想避免我老是需要传递参数
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102163949690.png" alt="image-20221102163949690" style="zoom:50%;" />![image-20221102223139081](C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223139081.png)



<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223139081.png" alt="image-20221102223139081" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223259662.png" alt="image-20221102223259662" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102223341047.png" alt="image-20221102223341047" style="zoom:40%;" />

```
以上三种解决方案是层层递进的。但无论用什么都会对性能有所影响。还是得看ThreadLocal
```



#### 第二种典型场景 part2

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102230123793.png" alt="image-20221102230123793" style="zoom:50%;" />

```java
package threadLocal;

/**
 * 演示ThreadLocal用法2: 避免传递参数的麻烦
 */
public class ThreadLocalNormalUsage06 {
    public static void main(String[] args) {
        new Service1().process();
    }}

class Service1 {
    public void process() {
        User user = new User("王小美");
        //这里ThreadLocal的用法和第一种典型用法有些不一样,不用一开始就赋初始值
        UserContextHolder.holder.set(user);
        //这里调用Service2的方法
        new Service2().process();
    }}

class Service2 {
    public void process() {
        //由Service1拿到对象就够了,后面就不再需要创建对象或读取了。通过get可以直接拿到这个对象
        User user = UserContextHolder.holder.get();
        System.out.println("Service2: " + user.name);
        new Service3().process();
    }}

class Service3 {
    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service3: " + user.name);
    }}

class UserContextHolder {
    //在这边会同样把 ThreadLocal定义为静态的,这是因为我们需要在多个方法中直接取到它,,,
    public static ThreadLocal<User> holder = new ThreadLocal<User>();
}

class User {
    String name;

    public User(String name) {
        this.name = name;
    }}
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102230318280.png" alt="image-20221102230318280" style="zoom:40%;" />

```
这两个对应不同的请求,由于它们并没有直接共享User对象,所以它们之间不会有线程安全问题。在整个第一个线程的整条链路中,它所拿到的都是"王小美",第二个拿到的都是王姐,所以用了ThreadLocal之后避免了synchronized同步,非常高效的实现了在不同的方法间共享对象的目标。
```



#### ThreadLocal的两个作用和好处

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102231046103.png" alt="image-20221102231046103" style="zoom:40%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102232012239.png" alt="image-20221102232012239" style="zoom:40%;" />

#### 根据共享对象的生成时机不同,选择initialValue或set来保存对象

```
有时候用initialValue,有时候用set,这是为什么该怎么选择?
	1.初始化时机完全受我们控制的,不受外界影响,用 initialValue
	2.对象生成时机可不由我们控制。 用set。(B比如拦截器拦截到信息再赋值)
,,
```

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102232329194.png" alt="image-20221102232329194" style="zoom:50%;" />

<img src="C:\Users\w1216\AppData\Roaming\Typora\typora-user-images\image-20221102232534215.png" alt="image-20221102232534215" style="zoom:50%;" />



,,



